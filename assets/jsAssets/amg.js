'use strict';Object.defineProperty(exports,"__esModule",{value:!0});class e{constructor(){this._callbacks={},this._callbackActive={}}_addCallback(e,t,a,n=!1){e&&"string"==typeof e&&t&&(!this._callbacks[e]&&(this._callbacks[e]=[]),this._callbackActive[e]&&this._callbackActive[e]===this._callbacks[e]&&(this._callbackActive[e]=this._callbackActive[e].slice()),this._callbacks[e].push({callback:t,scope:a||this,once:n}))}on(e,t,a){return this._addCallback(e,t,a,!1),this}off(e,t,a){if(e)this._callbackActive[e]&&this._callbackActive[e]===this._callbacks[e]&&(this._callbackActive[e]=this._callbackActive[e].slice());else for(const e in this._callbackActive)this._callbacks[e]&&this._callbacks[e]===this._callbackActive[e]&&(this._callbackActive[e]=this._callbackActive[e].slice());if(!e)this._callbacks={};else if(!t)this._callbacks[e]&&(this._callbacks[e]=[]);else{const n=this._callbacks[e];if(!n)return this;let r=n.length;for(let e=0;e<r;e++)n[e].callback===t&&(a&&n[e].scope!==a||(n[e--]=n[--r]));n.length=r}return this}fire(e,t,a,n,r,o,s,d,l){if(!e||!this._callbacks[e])return this;let c;this._callbackActive[e]?(this._callbackActive[e]===this._callbacks[e]&&(this._callbackActive[e]=this._callbackActive[e].slice()),c=this._callbacks[e].slice()):this._callbackActive[e]=this._callbacks[e];for(let p=0;(c||this._callbackActive[e])&&p<(c||this._callbackActive[e]).length;p++){const i=(c||this._callbackActive[e])[p];if(i.callback.call(i.scope,t,a,n,r,o,s,d,l),i.once){const t=this._callbacks[e].indexOf(i);-1!==t&&(this._callbackActive[e]===this._callbacks[e]&&(this._callbackActive[e]=this._callbackActive[e].slice()),this._callbacks[e].splice(t,1))}}return c||(this._callbackActive[e]=void 0),this}once(e,t,a){return this._addCallback(e,t,a,!0),this}hasEvent(e){return this._callbacks[e]&&0!==this._callbacks[e].length||!1}}const t=effect.Amaz,a=effect;class n extends e{constructor(e,t){super(),this.entity=e,this.nativeClass=t,e&&t&&(this.native=e.native.addComponent(t))}initialize(e,t){for(let a=0;a<t.length;a++){const n=t[a];e&&e.hasOwnProperty(n)&&(this[n]=e[n])}}initWithNative(e,t,a){this.entity=e,this.native=t,this.nativeClass=a}destroy(){this.entity&&this.nativeClass&&(this.entity.native.removeComponent(this.nativeClass),this.entity=void 0)}addListener(e,a,n){if(this.native)t.AmazingManager.addListener(this.native,e,a,n);else throw new Error("Invalid native component in Component:addListener")}removeListener(e,a){if(this.native)t.AmazingManager.removeListener(this.native,e,a);else throw new Error("Invalid native component in Component:removeListener")}get enabled(){return this.native.enabled}set enabled(e){this.native.enabled=e}}var i=t.PixelFormat;(function(e){e[e.Portrait=0]="Portrait",e[e.Landscape=1]="Landscape"})(exports.DeviceOrientationMode||(exports.DeviceOrientationMode={})),function(e){e[e.Perspective=t.CameraType.PERSPECTIVE]="Perspective",e[e.Orthographic=t.CameraType.ORTHO]="Orthographic"}(exports.CameraType||(exports.CameraType={})),function(e){e[e.AfterRender=t.CameraEvent.AFTER_RENDER]="AfterRender",e[e.BeforeRender=t.CameraEvent.BEFORE_RENDER]="BeforeRender",e[e.AfterEverything=t.CameraEvent.AFTER_EVERYTHING]="AfterEverything",e[e.AfterImageEffects=t.CameraEvent.AFTER_IMAGE_EFFECTS]="AfterImageEffects",e[e.RenderImageEffects=t.CameraEvent.RENDER_IMAGE_EFFECTS]="RenderImageEffects"}(exports.CameraRenderEvent||(exports.CameraRenderEvent={})),function(e){e[e.Nearest=t.FilterMode.NEAREST]="Nearest",e[e.Linear=t.FilterMode.LINEAR]="Linear"}(exports.TextureFilterMode||(exports.TextureFilterMode={})),function(e){e[e.Position=t.VertexAttribType.POSITION]="Position",e[e.Normal=t.VertexAttribType.NORMAL]="Normal",e[e.Tangent=t.VertexAttribType.TANGENT]="Tangent",e[e.Color=t.VertexAttribType.COLOR]="Color",e[e.Texcoord0=t.VertexAttribType.TEXCOORD0]="Texcoord0"}(exports.VertexAttribType||(exports.VertexAttribType={})),function(e){e[e.Directional=0]="Directional",e[e.Point=1]="Point",e[e.Spot=2]="Spot"}(exports.LightType||(exports.LightType={})),function(e){e[e.Box=0]="Box",e[e.Sphere=1]="Sphere",e[e.Capsule=2]="Capsule"}(exports.Collider3DType||(exports.Collider3DType={})),function(e){e[e.Static=t.RigidBodyType.STATIC]="Static",e[e.Kinematic=t.RigidBodyType.KINEMATIC]="Kinematic",e[e.Dynamic=t.RigidBodyType.DYNAMIC]="Dynamic"}(exports.Physics3DType||(exports.Physics3DType={})),function(e){e[e.Fit=t.StretchMode.fit]="Fit",e[e.Fill=t.StretchMode.fill]="Fill",e[e.FitWidth=t.StretchMode.fit_width]="FitWidth",e[e.FitHeight=t.StretchMode.fit_height]="FitHeight",e[e.Stretch=t.StretchMode.stretch]="Stretch",e[e.FillCut=t.StretchMode.fill_cut]="FillCut",e[e.ImageSize=t.StretchMode.texture_size]="ImageSize"}(exports.SpriteRenderMode||(exports.SpriteRenderMode={})),function(e){e[e.Normal=t.IFSprite2dType.Normal]="Normal",e[e.Tiled=t.IFSprite2dType.Tiled]="Tiled",e[e.Sliced=t.IFSprite2dType.Sliced]="Sliced",e[e.Filled=t.IFSprite2dType.Filled]="Filled",e[e.Ellipse=t.IFSprite2dType.Ellipse]="Ellipse",e[e.Free=t.IFSprite2dType.Free]="Free",e[e.Corner=t.IFSprite2dType.Corner]="Corner"}(exports.ImageRenderMode||(exports.ImageRenderMode={})),function(e){e[e.Horizontal=t.IFFilledType.Horizontal]="Horizontal",e[e.Vertical=t.IFFilledType.Vertical]="Vertical",e[e.Radial=t.IFFilledType.Radial]="Radial"}(exports.ImageFillType||(exports.ImageFillType={})),function(e){e[e.Normal=t.IFBlendMode.Normal]="Normal",e[e.Add=t.IFBlendMode.Add]="Add",e[e.Average=t.IFBlendMode.Average]="Average",e[e.Burn=t.IFBlendMode.Burn]="Burn",e[e.Dodge=t.IFBlendMode.Dodge]="Dodge",e[e.Darken=t.IFBlendMode.Darken]="Darken",e[e.Difference=t.IFBlendMode.Difference]="Difference",e[e.Exclusion=t.IFBlendMode.Exclusion]="Exclusion",e[e.Glow=t.IFBlendMode.Glow]="Glow",e[e.HardLight=t.IFBlendMode.Hardlight]="HardLight",e[e.HardMix=t.IFBlendMode.Hardmix]="HardMix",e[e.Lighten=t.IFBlendMode.Lighten]="Lighten",e[e.LinearBurn=t.IFBlendMode.Linearburn]="LinearBurn",e[e.LinearDodge=t.IFBlendMode.Lineardodge]="LinearDodge",e[e.LinearLight=t.IFBlendMode.Linearlight]="LinearLight",e[e.Multiply=t.IFBlendMode.Multiply]="Multiply",e[e.Negation=t.IFBlendMode.Negation]="Negation",e[e.Overlay=t.IFBlendMode.Overlay]="Overlay",e[e.Phoenix=t.IFBlendMode.Phoenix]="Phoenix",e[e.PinLight=t.IFBlendMode.Pinlight]="PinLight",e[e.Reflect=t.IFBlendMode.Reflect]="Reflect",e[e.Screen=t.IFBlendMode.Screen]="Screen",e[e.Softlight=t.IFBlendMode.Softlight]="Softlight",e[e.Substract=t.IFBlendMode.Substract]="Substract",e[e.VividLight=t.IFBlendMode.Vividlight]="VividLight",e[e.SnowColor=t.IFBlendMode.Snowcolor]="SnowColor",e[e.SnowHue=t.IFBlendMode.Snowhue]="SnowHue",e[e.EndFlag=t.IFBlendMode.EndFlag]="EndFlag"}(exports.CanvasBlendMode||(exports.CanvasBlendMode={})),function(e){e[e.None=t.IFMaskType.None]="None",e[e.Rect=t.IFMaskType.Rect]="Rect",e[e.Ellipse=t.IFMaskType.Ellipse]="Ellipse",e[e.Sprites=t.IFMaskType.MaskSprites]="Sprites"}(exports.CanvasMaskType||(exports.CanvasMaskType={})),function(e){e[e.Overlay=t.IFLayer2dRenderOrderMode.ScreenOverlay]="Overlay",e[e.Custom=t.IFLayer2dRenderOrderMode.SceneCustom]="Custom"}(exports.CanvasRenderOrder||(exports.CanvasRenderOrder={})),function(e){e[e.Once=t.PlayMode.once]="Once",e[e.Loop=t.PlayMode.loop]="Loop",e[e.PingPong=t.PlayMode.pingpong]="PingPong",e[e.Random=t.PlayMode.random]="Random"}(exports.SeqAnimationPlayMode||(exports.SeqAnimationPlayMode={})),function(e){e[e.Origin=t.IFResolutionType.Origin]="Origin",e[e.FitWidth=t.IFResolutionType.FitWidth]="FitWidth",e[e.FitHeight=t.IFResolutionType.FitHeight]="FitHeight",e[e.Fit=t.IFResolutionType.Fit]="Fit",e[e.Fill=t.IFResolutionType.Fill]="Fill"}(exports.CanvasScalerType||(exports.CanvasScalerType={})),function(e){e[e.Box=0]="Box"}(exports.UIColliderType||(exports.UIColliderType={})),function(e){e[e.Follow=t.IFUISliderMode.FOLLOW]="Follow",e[e.Offset=t.IFUISliderMode.OFFSET]="Offset",e[e.DragThumb=t.IFUISliderMode.DRAG_THUMB]="DragThumb"}(exports.SliderMode||(exports.SliderMode={})),function(e){e[e.LeftRight=t.IFUIMoveDirection.LEFT_TO_RIGHT]="LeftRight",e[e.RightLeft=t.IFUIMoveDirection.RIGHT_TO_LEFT]="RightLeft",e[e.BottomTop=t.IFUIMoveDirection.BOTTOM_TO_TOP]="BottomTop",e[e.TopBottom=t.IFUIMoveDirection.TOP_TO_BOTTOM]="TopBottom"}(exports.UIMoveDirection||(exports.UIMoveDirection={})),function(e){e[e.System=t.IFUILabelFontType.System]="System",e[e.TrueType=t.IFUILabelFontType.TrueType]="TrueType",e[e.Bitmap=t.IFUILabelFontType.Bitmap]="Bitmap"}(exports.LabelFontType||(exports.LabelFontType={})),function(e){e[e.Left=t.IFUILabelAlignment.Left]="Left",e[e.Right=t.IFUILabelAlignment.Right]="Right",e[e.Center=t.IFUILabelAlignment.Center]="Center"}(exports.LabelAlignment||(exports.LabelAlignment={})),function(e){e[e.AutoSize=t.IFUILabelFitType.AutoSize]="AutoSize",e[e.FitWidth=t.IFUILabelFitType.FitWidth]="FitWidth",e[e.FitSize=t.IFUILabelFitType.FitSize]="FitSize"}(exports.LabelFitType||(exports.LabelFitType={})),function(e){e[e.None=t.IFUIGridType.NONE]="None",e[e.Horizontal=t.IFUIGridType.HORIZONTAL]="Horizontal",e[e.Vertical=t.IFUIGridType.VERTICAL]="Vertical",e[e.Grid=t.IFUIGridType.GRID]="Grid"}(exports.LayoutType||(exports.LayoutType={})),function(e){e[e.None=t.IFUIGridResizeMode.NONE]="None",e[e.Container=t.IFUIGridResizeMode.CONTAINER]="Container",e[e.Children=t.IFUIGridResizeMode.CHILDREN]="Children"}(exports.LayoutSizeMode||(exports.LayoutSizeMode={})),function(e){e[e.Horizontal=t.IFUIGridStartAxis.HORIZONTAL]="Horizontal",e[e.Vertical=t.IFUIGridStartAxis.VERTICAL]="Vertical"}(exports.LayoutGridMode||(exports.LayoutGridMode={})),function(e){e[e.TopBottom=t.IFUIGridVerticalDirection.TOP_TO_BOTTOM]="TopBottom",e[e.BottomTop=t.IFUIGridVerticalDirection.BOTTOM_TO_TOP]="BottomTop"}(exports.LayoutVerticalDirection||(exports.LayoutVerticalDirection={})),function(e){e[e.LeftRight=t.IFUIGridHorizontalDirection.LEFT_TO_RIGHT]="LeftRight",e[e.RightLeft=t.IFUIGridHorizontalDirection.RIGHT_TO_LEFT]="RightLeft"}(exports.LayoutHorizontalDirection||(exports.LayoutHorizontalDirection={})),function(e){e[e.None=t.IFUIGridSortingType.NONE]="None",e[e.Alphabetic=t.IFUIGridSortingType.ALPHABETIC]="Alphabetic"}(exports.LayoutSortMode||(exports.LayoutSortMode={})),function(e){e.Head="head",e.Body="body",e.Hair="hair",e.Sky="sky",e.Building="building",e.Cloth="cloth",e.Ground="ground",e.Hand="hand"}(exports.SegmentationType||(exports.SegmentationType={}));const r=64,o=32;(function(e){e[e.Once=1]="Once",e[e.Loop=0]="Loop",e[e.PingPong=-1]="PingPong",e[e.Clamp=-2]="Clamp",e[e.Seek=-3]="Seek"})(exports.AnimationPlayMode||(exports.AnimationPlayMode={})),function(e){e[e.Billboard=t.ParticleQuatRendererOrientationType.BILLBOARD]="Billboard",e[e.Direction=t.ParticleQuatRendererOrientationType.DIRECTION]="Direction",e[e.Shape=t.ParticleQuatRendererOrientationType.SHAPE]="Shape",e[e.Fixed=t.ParticleQuatRendererOrientationType.FIXED]="Fixed"}(exports.ParticleSystemRenderOrientation||(exports.ParticleSystemRenderOrientation={})),function(e){e[e.ByDistance=t.ParticleRenderSortingMode.BY_DISTANCE]="ByDistance",e[e.OldestInFront=t.ParticleRenderSortingMode.OLDEST_IN_FRONT]="OldestInFront",e[e.YoungestInFront=t.ParticleRenderSortingMode.YOUNGEST_IN_FRONT]="YoungestInFront"}(exports.ParticleSystemRenderSortingMode||(exports.ParticleSystemRenderSortingMode={})),function(e){e[e.Quad=0]="Quad",e[e.Mesh=1]="Mesh"}(exports.ParticleSystemRenderType||(exports.ParticleSystemRenderType={})),function(e){e[e.ScaleByParticle=t.ParticleMeshRendererType.SCALE_BY_PARTICLE]="ScaleByParticle",e[e.SizeByParticle=t.ParticleMeshRendererType.SIZE_BY_PARTICLE]="SizeByParticle"}(exports.ParticleSystemRenderDisplayMode||(exports.ParticleSystemRenderDisplayMode={})),function(e){e[e.None=0]="None",e[e.Color=1]="Color"}(exports.ParticleSystemAffector||(exports.ParticleSystemAffector={})),function(e){e[e.Set=t.ColorOperation.SET]="Set",e[e.Multiply=t.ColorOperation.MULTIPLY]="Multiply",e[e.Random=t.ColorOperation.RANDOM]="Random"}(exports.ParticleSystemColorAffectorOperation||(exports.ParticleSystemColorAffectorOperation={})),function(e){e[e.Unknown=0]="Unknown",e[e.Human=1]="Human",e[e.Cat=2]="Cat",e[e.Dog=3]="Dog"}(exports.FaceType||(exports.FaceType={})),function(e){e[e.Whole=0]="Whole",e[e.LeftEye=1]="LeftEye",e[e.RightEye=2]="RightEye",e[e.Nose=3]="Nose",e[e.Mouth=4]="Mouth",e[e.LeftEyeBrow=5]="LeftEyeBrow",e[e.RightEyeBrow=6]="RightEyeBrow",e[e.LeftEar=7]="LeftEar",e[e.RightEar=8]="RightEar"}(exports.FacePart||(exports.FacePart={})),function(e){e[e.Unknown=0]="Unknown",e[e.Angry=1]="Angry",e[e.Disgust=2]="Disgust",e[e.Fear=3]="Fear",e[e.Happy=4]="Happy",e[e.Sad=5]="Sad",e[e.Surprise=6]="Surprise",e[e.Neutral=7]="Neutral"}(exports.FaceExpression||(exports.FaceExpression={})),function(e){e.Detected="detected",e.Lost="lost"}(exports.FaceEvent||(exports.FaceEvent={})),function(e){e[e.None=0]="None",e[e.EyeBlink=1]="EyeBlink",e[e.EyeBlinkLeft=2]="EyeBlinkLeft",e[e.EyeBlinkRight=3]="EyeBlinkRight",e[e.MouthAh=4]="MouthAh",e[e.MouthPout=5]="MouthPout",e[e.HeadYaw=6]="HeadYaw",e[e.HeadPitch=7]="HeadPitch",e[e.BrowJump=8]="BrowJump",e[e.SideNod=9]="SideNod"}(exports.FaceAction||(exports.FaceAction={})),function(e){e[e.Face106=0]="Face106",e[e.Face240=1]="Face240",e[e.Face280=2]="Face280",e[e.Face3d=3]="Face3d",e[e.PetV2=4]="PetV2"}(exports.FaceLandmarkType||(exports.FaceLandmarkType={})),function(e){e.Lost="lost",e.Detected="detected",e.StaticGesture="staticGesture",e.DynamicGesture="dynamicGesture"}(exports.HandEvent||(exports.HandEvent={})),function(e){e[e.HeartA=0]="HeartA",e[e.HeartB=1]="HeartB",e[e.HeartC=2]="HeartC",e[e.HeartD=3]="HeartD",e[e.OK=4]="OK",e[e.HandOpen=5]="HandOpen",e[e.ThumbUp=6]="ThumbUp",e[e.ThumbDown=7]="ThumbDown",e[e.Rock=8]="Rock",e[e.Namaste=9]="Namaste",e[e.PalmUp=10]="PalmUp",e[e.Fist=11]="Fist",e[e.IndexFingerUp=12]="IndexFingerUp",e[e.DoubleFingerUp=13]="DoubleFingerUp",e[e.Victory=14]="Victory",e[e.BigV=15]="BigV",e[e.PhoneCall=16]="PhoneCall",e[e.Beg=17]="Beg",e[e.Thanks=18]="Thanks",e[e.Unknown=19]="Unknown",e[e.Cabbage=20]="Cabbage",e[e.Three=21]="Three",e[e.Four=22]="Four",e[e.Pistol=23]="Pistol",e[e.Rock2=24]="Rock2",e[e.Swear=25]="Swear",e[e.HoldFace=26]="HoldFace",e[e.Salute=27]="Salute",e[e.Spread=28]="Spread",e[e.Pray=29]="Pray",e[e.QiGong=30]="QiGong",e[e.Slide=31]="Slide",e[e.PalmDown=32]="PalmDown",e[e.Pistol2=33]="Pistol2",e[e.NinjaMudra1=34]="NinjaMudra1",e[e.NinjaMudra2=35]="NinjaMudra2",e[e.NinjaMudra3=36]="NinjaMudra3",e[e.NinjaMudra4=37]="NinjaMudra4",e[e.NinjaMudra5=38]="NinjaMudra5",e[e.NinjaMudra6=39]="NinjaMudra6",e[e.NinjaMudra7=40]="NinjaMudra7",e[e.NinjaMudra8=41]="NinjaMudra8",e[e.NinjaMudra9=42]="NinjaMudra9",e[e.NinjaMudra10=43]="NinjaMudra10",e[e.NinjaMudra11=44]="NinjaMudra11",e[e.SpiderHand=45]="SpiderHand",e[e.AvengerHand=46]="AvengerHand",e[e.MaxCount=47]="MaxCount",e[e.Undetect=48]="Undetect",e[e.None=99]="None"}(exports.HandStaticGesture||(exports.HandStaticGesture={})),function(e){e[e.None=0]="None",e[e.Punching=1]="Punching",e[e.Clapping=2]="Clapping",e[e.HighFive=4]="HighFive"}(exports.HandDynamicGesture||(exports.HandDynamicGesture={})),function(e){e[e.Wrist=0]="Wrist",e[e.Thumb3=1]="Thumb3",e[e.Thumb2=2]="Thumb2",e[e.Thumb1=3]="Thumb1",e[e.Thumb0=4]="Thumb0",e[e.Index3=5]="Index3",e[e.Index2=6]="Index2",e[e.Index1=7]="Index1",e[e.Index0=8]="Index0",e[e.Middle3=9]="Middle3",e[e.Middle2=10]="Middle2",e[e.Middle1=11]="Middle1",e[e.Middle0=12]="Middle0",e[e.Ring3=13]="Ring3",e[e.Ring2=14]="Ring2",e[e.Ring1=15]="Ring1",e[e.Ring0=16]="Ring0",e[e.Pinky3=17]="Pinky3",e[e.Pinky2=18]="Pinky2",e[e.Pinky1=19]="Pinky1",e[e.Pinky0=20]="Pinky0",e[e.Center=21]="Center"}(exports.HandKeyPoint||(exports.HandKeyPoint={})),function(e){e.Detected="detected",e.Lost="lost",e.Action="action"}(exports.BodyEvent||(exports.BodyEvent={})),function(e){e[e.Nose=0]="Nose",e[e.Neck=1]="Neck",e[e.RightShoulder=2]="RightShoulder",e[e.RightElbow=3]="RightElbow",e[e.RightWrist=4]="RightWrist",e[e.LeftShoulder=5]="LeftShoulder",e[e.LeftElbow=6]="LeftElbow",e[e.LeftWrist=7]="LeftWrist",e[e.RightHip=8]="RightHip",e[e.RightKnee=9]="RightKnee",e[e.RightAnkle=10]="RightAnkle",e[e.LeftHip=11]="LeftHip",e[e.LeftKnee=12]="LeftKnee",e[e.LeftAnkle=13]="LeftAnkle",e[e.RightEye=14]="RightEye",e[e.LeftEye=15]="LeftEye",e[e.RightEar=16]="RightEar",e[e.LeftEar=17]="LeftEar"}(exports.Body2DKeyPointType||(exports.Body2DKeyPointType={})),function(e){e[e.Hips=0]="Hips",e[e.LeftUpLeg=1]="LeftUpLeg",e[e.RightUpLeg=2]="RightUpLeg",e[e.Spine=3]="Spine",e[e.LeftLeg=4]="LeftLeg",e[e.RightLeg=5]="RightLeg",e[e.Spine1=6]="Spine1",e[e.LeftFoot=7]="LeftFoot",e[e.RightFoot=8]="RightFoot",e[e.Spine2=9]="Spine2",e[e.LeftToe=10]="LeftToe",e[e.RightToe=11]="RightToe",e[e.Neck=12]="Neck",e[e.LeftShoulder=13]="LeftShoulder",e[e.RightShoulder=14]="RightShoulder",e[e.Head=15]="Head",e[e.LeftArm=16]="LeftArm",e[e.RightArm=17]="RightArm",e[e.LeftForeArm=18]="LeftForeArm",e[e.RightForeArm=19]="RightForeArm",e[e.LeftHand=20]="LeftHand",e[e.RightHand=21]="RightHand"}(exports.Body3DKeyPointType||(exports.Body3DKeyPointType={})),function(e){e.Detected="detected",e.Lost="lost"}(exports.AvatarDriveEvent||(exports.AvatarDriveEvent={})),function(e){e[e.LeftEyeLookDown=0]="LeftEyeLookDown",e[e.LeftNoseSneer=1]="LeftNoseSneer",e[e.LeftEyeLookIn=2]="LeftEyeLookIn",e[e.BrowInnerUp=3]="BrowInnerUp",e[e.LeftEyeSquint=4]="LeftEyeSquint",e[e.MouthClose=5]="MouthClose",e[e.RightMouthLowerDown=6]="RightMouthLowerDown",e[e.JawOpen=7]="JawOpen",e[e.MouthShrugLower=8]="MouthShrugLower",e[e.LeftMouthLowerDown=9]="LeftMouthLowerDown",e[e.MouthFunnel=10]="MouthFunnel",e[e.RightEyeLookIn=11]="RightEyeLookIn",e[e.RightEyeLookDown=12]="RightEyeLookDown",e[e.RightNoseSneer=13]="RightNoseSneer",e[e.MouthRollUpper=14]="MouthRollUpper",e[e.JawRight=15]="JawRight",e[e.LeftMouthDimple=16]="LeftMouthDimple",e[e.MouthRollLower=17]="MouthRollLower",e[e.LeftMouthSmile=18]="LeftMouthSmile",e[e.LeftMouthPress=19]="LeftMouthPress",e[e.RightMouthSmile=20]="RightMouthSmile",e[e.RightMouthPress=21]="RightMouthPress",e[e.RightMouthDimple=22]="RightMouthDimple",e[e.MouthLeft=23]="MouthLeft",e[e.RightBrowDown=24]="RightBrowDown",e[e.LeftBrowDown=25]="LeftBrowDown",e[e.LeftMouthFrown=26]="LeftMouthFrown",e[e.LeftEyeBlink=27]="LeftEyeBlink",e[e.LeftCheekSquint=28]="LeftCheekSquint",e[e.LeftBrowOuterUp=29]="LeftBrowOuterUp",e[e.LeftEyeLookUp=30]="LeftEyeLookUp",e[e.JawLeft=31]="JawLeft",e[e.LeftMouthStretch=32]="LeftMouthStretch",e[e.RightMouthStretch=33]="RightMouthStretch",e[e.MouthPucker=34]="MouthPucker",e[e.RightEyeLookUp=35]="RightEyeLookUp",e[e.RightBrowOuterUp=36]="RightBrowOuterUp",e[e.RightCheekSquint=37]="RightCheekSquint",e[e.RightEyeBlink=38]="RightEyeBlink",e[e.LeftMouthUpperUp=39]="LeftMouthUpperUp",e[e.RightMouthFrown=40]="RightMouthFrown",e[e.RightEyeSquint=41]="RightEyeSquint",e[e.JawForward=42]="JawForward",e[e.RightMouthUpperUp=43]="RightMouthUpperUp",e[e.CheekPuff=44]="CheekPuff",e[e.LeftEyeLookOut=45]="LeftEyeLookOut",e[e.RightEyeLookOut=46]="RightEyeLookOut",e[e.RightEyeWide=47]="RightEyeWide",e[e.MouthRight=48]="MouthRight",e[e.LeftEyeWide=49]="LeftEyeWide",e[e.MouthShrugUpper=50]="MouthShrugUpper",e[e.TongueOut=51]="TongueOut"}(exports.AvatarDriveBlendShapeType||(exports.AvatarDriveBlendShapeType={})),function(e){e.Texture="texture",e.Mesh="mesh"}(exports.AssetType||(exports.AssetType={})),function(e){e.Segmentation="segmentation",e.Face="face",e.CameraInput="cameraInput",e.ImagePicker="imagePicker"}(exports.AssetSubType||(exports.AssetSubType={})),function(e){e.Possible="possible",e.Began="began",e.Changed="changed",e.Ended="ended",e.Cancelled="cancelled",e.Failed="failed"}(exports.GestureRecognizerState||(exports.GestureRecognizerState={})),function(e){e.Tap="tap",e.Pan="pan",e.Pinch="pinch",e.Rotation="rotation",e.LongPress="longPress",e.DoubleTap="doubleTap"}(exports.GestureType||(exports.GestureType={})),function(e){e[e.AR=0]="AR",e[e.UI=1]="UI",e[e.ThreeD=2]="ThreeD",e[e.TwoD=3]="TwoD",e[e.Other=4]="Other"}(exports.ScreenRaycasterType||(exports.ScreenRaycasterType={})),function(e){e.Began="screenRespondBegan",e.Ended="screenRespondEnded",e.Respond="screenRespond"}(exports.ScreenRespondType||(exports.ScreenRespondType={})),function(e){e[e.Once=0]="Once",e[e.Continuous=1]="Continuous"}(exports.TouchRespondType||(exports.TouchRespondType={})),function(e){e.File="file",e.Mic="mic",e.Music="music"}(exports.AudioControllerType||(exports.AudioControllerType={})),function(e){e[e.Preparing=0]="Preparing",e[e.Playing=1]="Playing",e[e.Stoping=2]="Stoping",e[e.Stopped=3]="Stopped",e[e.Pausing=4]="Pausing",e[e.Paused=5]="Paused",e[e.Exception=-1]="Exception"}(exports.AudioFileControllerState||(exports.AudioFileControllerState={})),function(e){e.Reverb="reverb",e.Megaphone="megaphone",e.Compressor="compressor",e.Delay="delay",e.Filter="filter",e.Vibrato="vibrato",e.Limiter="limiter"}(exports.AudioEffectType||(exports.AudioEffectType={})),function(e){e[e.LowPass=0]="LowPass",e[e.HighPass=1]="HighPass"}(exports.AudioEffectFilterType||(exports.AudioEffectFilterType={})),function(e){e.Energy="energyDetection",e.PitchDetection="pitchDetection",e.BeatsDetection="beatsDetection",e.VolumeDetection="volumeDetection",e.OnsetDetection="onsetDetection"}(exports.AudioExtractorType||(exports.AudioExtractorType={})),function(e){e.Play="play",e.Pause="pause",e.Resume="resume",e.Stop="stop",e.LoopCompletion="loopCompletion"}(exports.AudioEvent||(exports.AudioEvent={}));const s=["clearColor","clearColorBuffer","clearDepthBuffer","clearStencilBuffer","orthoHeight","near","far","fov","type","viewport","layers","renderOrder"];class d extends n{constructor(e,a){if(e){super(e,"Camera");const n=new t.DynamicBitset(r,0);n.set(0,1),this.native.layerVisibleMask=n,this.initialize(a,s),this.native.renderTexture=new t.SceneOutputRT}else super()}static fromNative(e,a){const n=new d;if(a instanceof t.Camera)n.initWithNative(e,a,"Camera");else throw new Error("Incorrect argument to CameraComponent::fromNative");return n}get renderTexture(){return this.native.renderTexture}set renderTexture(e){this.native.renderTexture=e}get clearColor(){return this.native.clearColor}set clearColor(e){this.native.clearColor=e}get clearColorBuffer(){const e=this.native.clearType;return 1===e||3===e||7===e}set clearColorBuffer(e){let t=this.native.clearType;0===t||4===t||5===t?t=e?1:t:1===t?t=e?1:5:2===t||3===t?t=e?3:2:6===t||7===t?t=e?7:6:void 0;this.native.clearType=t}get clearDepthBuffer(){const e=this.native.clearType;return 2===e||3===e||6===e||7===e}set clearDepthBuffer(e){let t=this.native.clearType;0===t||4===t||5===t?t=e?2:t:1===t||3===t?t=e?3:1:2===t?t=e?e:5:6===t?t=e?6:5:7===t?t=e?7:1:void 0;this.native.clearType=t}get clearStencilBuffer(){const e=this.native.clearType;return 6===e||7===e}set clearStencilBuffer(e){let t=this.native.clearType;0===t||4===t||5===t?t=e?6:t:1===t||3===t?t=e?7:t:2===t||6===t?t=e?6:2:7===t?t=e?7:1:void 0;this.native.clearType=t}get orthoHeight(){return this.native.orthoScale}set orthoHeight(e){this.native.orthoScale=e}get near(){return this.native.zNear}set near(e){this.native.zNear=e}get far(){return this.native.zFar}set far(e){this.native.zFar=e}get fov(){return this.native.fovy}set fov(e){this.native.fovy=e}get type(){return this.native.type}set type(e){this.native.type=e}get viewport(){return this.native.viewport}set viewport(e){this.native.viewport=e}get layers(){const e=[];for(let t=0;t<r;++t)this.native.layerVisibleMask.test(t)&&e.push(t);return e}set layers(e){const a=new t.DynamicBitset(r,0);for(const t of e)if(0<=t&&t<r)a.set(t);else throw new Error("Invalid layer value!");this.native.layerVisibleMask=a}get renderOrder(){return this.native.renderOrder}set renderOrder(e){this.native.renderOrder=e}screenToWorld(e){return this.native.screenToWorldPoint(e)}worldToScreen(e){return this.native.worldToScreenPoint(e)}}d.nativeClasses=["Camera"];const l=["type","offset","halfExtents","radius","height"],c=new Map([[exports.Collider3DType.Box,"BoxCollider3D"],[exports.Collider3DType.Sphere,"SphereCollider3D"],[exports.Collider3DType.Capsule,"CapsuleCollider3D"]]);function p(e){if(!c.has(e))throw new Error("Unknown type of shape");return c.get(e)}class u extends n{constructor(e,t){if(e){const a=t&&t.hasOwnProperty("type")?t:{type:exports.Collider3DType.Box};super(e,p(a.type)),this.initialize(a,l)}else super()}static fromNative(e,a){const n=new u;if(a instanceof t.BoxCollider3D)n.initWithNative(e,a,"BoxCollider3D"),n.type=exports.Collider3DType.Box;else if(a instanceof t.SphereCollider3D)n.initWithNative(e,a,"SphereCollider3D"),n.type=exports.Collider3DType.Sphere;else if(a instanceof t.CapsuleCollider3D)n.initWithNative(e,a,"CapsuleCollider3D"),n.type=exports.Collider3DType.Capsule;else throw new Error("Incorrect argument to CollisionComponent::fromNative");return n}get offset(){return this.native.offset}set offset(e){this.native.offset=e}get radius(){return this.native.radius}set radius(e){this.native.radius=e}get height(){return this.native.height}set height(e){this.native.height=e}get halfExtents(){return this.native.halfExtent}set halfExtents(e){this.native.halfExtent=e}}u.nativeClasses=["BoxCollider3D","SphereCollider3D","CapsuleCollider3D"];var m=t.Color,g=t.Vector3f;g.prototype.clone=function(){return this.copy()},g.prototype.subtract=function(e,t){if(t){const a=g.sub(e,t);this.set(a.x,a.y,a.z)}else this.sub(e);return this},g.prototype.cross2=function(e,t){const a=e.cross(t);return this.set(a.x,a.y,a.z),this};const _=new Map([[exports.LightType.Directional,"DirectionalLight"],[exports.LightType.Point,"PointLight"],[exports.LightType.Spot,"SpotLight"]]);function f(e){if(!_.has(e))throw new Error("Unknown type of light");return _.get(e)}const h=["type","color","intensity","castShadow","enableSoftShadow","shadowSoftness","shadowBias","camera","shadowResolution","attenuationRange"];class y extends n{constructor(e,t){if(e){const a=t&&t.hasOwnProperty("type")?t:{type:exports.LightType.Directional};super(e,f(a.type)),this.initialize(a,h)}else super()}static fromNative(e,a){const n=new y;if(a instanceof t.DirectionalLight)n.initWithNative(e,a,"DirectionalLight"),n.type=exports.LightType.Directional;else if(a instanceof t.PointLight)n.initWithNative(e,a,"PointLight"),n.type=exports.LightType.Point;else if(a instanceof t.SpotLight)n.initWithNative(e,a,"SpotLight"),n.type=exports.LightType.Spot;else throw new Error("Incorrect argument to LightComponent::fromNative");return n}get color(){const e=this.native.color;return new m(e.x,e.y,e.z,1)}set color(e){this.native.color=new g(e.r,e.g,e.b)}get intensity(){return this.native.intensiy}set intensity(e){this.native.intensiy=e}get castShadow(){return this.native.shadowEnableNew}set castShadow(e){this.native.shadowEnableNew=e}get enableSoftShadow(){return this.native.useSoftShadow}set enableSoftShadow(e){this.native.useSoftShadow=e}get shadowSoftness(){return this.native.shadowSoftness}set shadowSoftness(e){this.native.shadowSoftness=e}get shadowBias(){return this.native.shadowBias}set shadowBias(e){this.native.shadowBias=e}get shadowResolution(){return this.native.shadowResolution}set shadowResolution(e){this.native.shadowResolution=e}get attenuationRange(){if(this.type===exports.LightType.Point||this.type===exports.LightType.Spot)return this.native.attenuationRange;throw new Error("Light Type does not support attenuationRange!")}set attenuationRange(e){if(this.type===exports.LightType.Point||this.type===exports.LightType.Spot)this.native.attenuationRange=e;else throw new Error("Light Type does not support attenuationRange!")}get camera(){if(this.type===exports.LightType.Directional){var e,t,a,n;return null==(e=this.entity)||null==(t=e.scene)?void 0:t.entityFromNative(null==(a=this.native)||null==(n=a.mainCamera)?void 0:n.entity)}}set camera(e){if(!(this.type===exports.LightType.Directional))throw new Error("Only directional light needs cameera for shadow optimization!");else if(e)if(e.native)this.native.mainCamera=e.native.getComponent("Transform");else throw new Error("Invalid camera!")}}y.nativeClasses=["DirectionalLight","PointLight","SpotLight"];var T=t.Vector2f,S=t.Vector4f;S.prototype.clone=function(){return this.copy()};var C=t.Matrix4x4f;class I{constructor(e){this.native=e?e:new t.Material}set xshader(e){this.native.xshader=e.native}clone(){return new I(this.native.instantiate())}addProperty(e,a){Object.defineProperty(this,e,{configurable:!0,get:function(){let n;if("number"==typeof a)n=this.native.getFloat(e);else if(a instanceof T)n=this.native.getVec2(e);else if(a instanceof g)n=this.native.getVec3(e);else if(a instanceof S)n=this.native.getVec4(e);else if(a instanceof t.Color){const a=this.native.getVec4(e);n=new t.Color(a.x,a.y,a.z,a.w)}else n=a instanceof C?this.native.getMat4(e):this.native.getTex(e);return n},set:function(a){if("number"==typeof a)this.native.setFloat(e,a);else if(a instanceof T)this.native.setVec2(e,a);else if(a instanceof g)this.native.setVec3(e,a);else if(a instanceof S)this.native.setVec4(e,a);else if(a instanceof t.Color){const t=new S(a.r,a.g,a.b,a.a);this.native.setVec4(e,t)}else a instanceof C?this.native.setMat4(e,a):this.native.setTex(e,a)}}),this[e]=a}removeProperty(e){Object.defineProperty(this,e,{configurable:!0,value:void 0})}addMacro(e,t){this.native.enableMacro(e,t)}removeMacro(e){this.native.disableMacro(e)}}const x=["castShadow","mesh","material"];class P extends n{constructor(e,t){e?(super(e,"MeshRenderer"),this.initialize(t,x)):super()}static fromNative(e,a){const n=new P;if(a instanceof t.MeshRenderer)n.initWithNative(e,a,"MeshRenderer");else throw new Error("Incorrect argument to ModelComponent::fromNative");return n}get castShadow(){return this.native.castShadow}set castShadow(e){this.native.castShadow=e}get mesh(){return this.native.mesh}set mesh(e){this.native.mesh=e}get material(){if(!this._material){const e=this.native.material;e&&(this._material=new I(e))}return this._material}set material(e){e&&(this._material=e,this.native.material=e.native)}}P.nativeClasses=["MeshRenderer"];const M=Math.PI/180;var R=t.Quaternionf;R.prototype.clone=function(){return this.copy()},R.prototype.eulerAngles=function(e,t,a){const n=this.eulerToQuaternion(new g(e*M,t*M,a*M));return this.set(n.x,n.y,n.z,n.w),this},R.prototype.toAxisAngle=function(){var e=Math.sqrt,t=Math.acos;const a=new g,n=2*t(this.w),i=e(1-this.w*this.w);return .001>i?(a.x=this.x,a.y=this.y,a.z=this.z):(a.x=this.x/i,a.y=this.y/i,a.z=this.z/i),[a,n]},R.prototype.fromToRotation=function(e,t){const a=R.fromToQuaternionSafe(e,t);return this.set(a.x,a.y,a.z,a.w),this};const F=["autoPlay","flipDirection","totalParticles","material","emitterRadius","emissionRate","lifetime","scale","angle","speed","rotationX","rotationY","rotationZ","rotationXSpeed","rotationYSpeed","rotationZSpeed","colors","orientation","sortingMode","renderType","mesh","displayMode","orientationStart","orientationEnd","affectorType","colorAffectorOperation","colorAffectorColors"];class A extends n{constructor(e,a){if(e){super(e,"ParticleComponent");let n;if(n=a&&a.hasOwnProperty("renderType")?a.renderType:exports.ParticleSystemRenderType.Quad,n==exports.ParticleSystemRenderType.Mesh)this.native.renderer=new t.ParticleMeshRenderer;else if(n==exports.ParticleSystemRenderType.Quad)this.native.renderer=new t.ParticleQuatRenderer;else throw new Error("Incorrect options: renderType");let i;if(a&&a.hasOwnProperty("affectorType")&&(i=a.affectorType),i==exports.ParticleSystemAffector.Color){const e=new t.Vector;e.pushBack(new t.ColorAffector),this.native.affectors=e}const r=new t.Vector;r.pushBack(new t.CircleEmitter),this.native.emitters=r,this.initialize(a,this.getProps())}else super()}static fromNative(e,a){const n=new A;if(a instanceof t.ParticleComponent)n.initWithNative(e,a,"ParticleComponent");else throw new Error("Incorrect argument to ParticleSystemComponent::fromNative");return n}getEmitter(){const e=this.native.emitters.get(0);return e instanceof t.CircleEmitter?e:void 0}getAffector(){const e=this.native.affectors.get(0);return e instanceof t.ColorAffector?e:void 0}getProps(){return F}isPlaying(){return this.native.isStarted()}start(){const e=this.getEmitter();return e&&(e.enable=!0),this.native.start()}stop(){return this.native.stop()}resume(){return this.native.resume()}pause(){return this.native.pause()}get orientation(){if(this.native.renderer instanceof t.ParticleQuatRenderer)return this.native.renderer.orientationType;throw new Error("Not supported param for render type")}set orientation(e){if(this.native.renderer instanceof t.ParticleQuatRenderer)this.native.renderer.orientationType=e;else throw new Error("Not supported param for render type")}get sortingMode(){return this.native.renderer.sortingMode}set sortingMode(e){this.native.renderer.sortingMode=e}get displayMode(){if(this.native.renderer instanceof t.ParticleMeshRenderer)return this.native.renderer.displayMode;throw new Error("Not supported param for render type")}set displayMode(e){if(this.native.renderer instanceof t.ParticleMeshRenderer)this.native.renderer.displayMode=e;else throw new Error("Not supported param for render type")}get mesh(){return this.native.renderer.templateMesh}set mesh(e){this.native.renderer.templateMesh=e}get autoPlay(){return this.native.autoStart}set autoPlay(e){this.native.autoStart=e}get flipDirection(){return this.native.flipY}set flipDirection(e){this.native.flipY=e}get totalParticles(){return this.native.particleQuota}set totalParticles(e){this.native.particleQuota=e}get material(){if(!this._material){const e=this.native.material;e&&(this._material=new I(e))}return this._material}set material(e){e&&(this._material=e,this.native.material=e.native)}get emitterRadius(){const e=this.getEmitter();if(e)return{min:e.inner_radius,max:e.radius};throw new Error("Invalid emitter in ParticleSystemComponent::get emitterRadius")}set emitterRadius(e){const t=this.getEmitter();if(t)t.innder_radius=e.min,t.radius=e.max;else throw new Error("Invalid emitter in ParticleSystemComponent::set emitterRadius")}get emissionRate(){const e=this.getEmitter();if(e){const t=e.emissionRate;return{min:t.min,max:t.max}}throw new Error("Invalid emitter in ParticleSystemComponent::get emissionRate")}set emissionRate(e){const t=this.getEmitter();if(t){const a=t.emissionRate;a.min=e.min,a.max=e.max}else throw new Error("Invalid emitter in ParticleSystemComponent::set emissionRate")}get lifetime(){const e=this.getEmitter();if(e){const t=e.totalTimeToLive;return{min:t.min,max:t.max}}throw new Error("Invalid emitter in ParticleSystemComponent::get lifetime")}set lifetime(e){const t=this.getEmitter();if(t){const a=t.totalTimeToLive;a.min=e.min,a.max=e.max}else throw new Error("Invalid emitter in ParticleSystemComponent::set lifetime")}get scale(){const e=this.getEmitter();if(e){const t=e.particleScale;return{min:t.min,max:t.max}}throw new Error("Invalid emitter in ParticleSystemComponent::get scale")}set scale(e){const t=this.getEmitter();if(t){const a=t.particleScale;a.min=e.min,a.max=e.max}else throw new Error("Invalid emitter in ParticleSystemComponent::set scale")}get angle(){const e=this.getEmitter();if(e){const t=e.angle;return{min:t.min,max:t.max}}throw new Error("Invalid emitter in ParticleSystemComponent::get angle")}set angle(e){const t=this.getEmitter();if(t){const a=t.angle;a.min=e.min,a.max=e.max}else throw new Error("Invalid emitter in ParticleSystemComponent::set angle")}get speed(){const e=this.getEmitter();if(e){const t=e.particleVelocity;return{min:t.min,max:t.max}}throw new Error("Invalid emitter in ParticleSystemComponent::get speed")}set speed(e){const t=this.getEmitter();if(t){const a=t.particleVelocity;a.min=e.min,a.max=e.max}else throw new Error("Invalid emitter in ParticleSystemComponent::set speed")}get rotationX(){const e=this.getEmitter();if(e){const t=e.particleXRotation;return{min:t.min,max:t.max}}throw new Error("Invalid emitter in ParticleSystemComponent::get rotationX")}set rotationX(e){const t=this.getEmitter();if(t){const a=t.particleXRotation;a.min=e.min,a.max=e.max}else throw new Error("Invalid emitter in ParticleSystemComponent::set rotationX")}get rotationY(){const e=this.getEmitter();if(e){const t=e.particleYRotation;return{min:t.min,max:t.max}}throw new Error("Invalid emitter in ParticleSystemComponent::get rotationY")}set rotationY(e){const t=this.getEmitter();if(t){const a=t.particleYRotation;a.min=e.min,a.max=e.max}else throw new Error("Invalid emitter in ParticleSystemComponent::set rotationY")}get rotationZ(){const e=this.getEmitter();if(e){const t=e.particleZRotation;return{min:t.min,max:t.max}}throw new Error("Invalid emitter in ParticleSystemComponent::get rotationZ")}set rotationZ(e){const t=this.getEmitter();if(t){const a=t.particleZRotation;a.min=e.min,a.max=e.max}else throw new Error("Invalid emitter in ParticleSystemComponent::set rotationZ")}get rotationXSpeed(){const e=this.getEmitter();if(e){const t=e.particleXRotationSpeed;return{min:t.min,max:t.max}}throw new Error("Invalid emitter in ParticleSystemComponent::get rotationXSpeed")}set rotationXSpeed(e){const t=this.getEmitter();if(t){const a=t.particleXRotationSpeed;a.min=e.min,a.max=e.max}else throw new Error("Invalid emitter in ParticleSystemComponent::set rotationXSpeed")}get rotationYSpeed(){const e=this.getEmitter();if(e){const t=e.particleYRotationSpeed;return{min:t.min,max:t.max}}throw new Error("Invalid emitter in ParticleSystemComponent::get rotationYSpeed")}set rotationYSpeed(e){const t=this.getEmitter();if(t){const a=t.particleYRotationSpeed;a.min=e.min,a.max=e.max}else throw new Error("Invalid emitter in ParticleSystemComponent::set rotationYSpeed")}get rotationZSpeed(){const e=this.getEmitter();if(e){const t=e.particleZRotationSpeed;return{min:t.min,max:t.max}}throw new Error("Invalid emitter in ParticleSystemComponent::get rotationZSpeed")}set rotationZSpeed(e){const t=this.getEmitter();if(t){const a=t.particleZRotationSpeed;a.min=e.min,a.max=e.max}else throw new Error("Invalid emitter in ParticleSystemComponent::set rotationZSpeed")}set colors(e){const a=this.getEmitter();if(a){const n=new t.Vec4Vector;for(const t of e)n.pushBack(new S(t.r,t.g,t.b,t.a));a.particleColorList=n}else throw new Error("Invalid emitter in ParticleSystemComponent::set colors")}get orientationStart(){const e=this.getEmitter();if(e)return e.orientationStart.quaternionToEuler();throw new Error("Invalid emitter in ParticleSystemComponent::get orientationStart")}set orientationStart(e){const t=this.getEmitter();if(t)t.orientationStart=new R().eulerAngles(e.x,e.y,e.z);else throw new Error("Invalid emitter in ParticleSystemComponent::set orientationStart")}get orientationEnd(){const e=this.getEmitter();if(e)return e.orientationEnd.quaternionToEuler();throw new Error("Invalid emitter in ParticleSystemComponent::get orientationEnd")}set orientationEnd(e){const t=this.getEmitter();if(t)t.orientationEnd=new R().eulerAngles(e.x,e.y,e.z);else throw new Error("Invalid emitter in ParticleSystemComponent::set orientationEnd")}get colorAffectorOperation(){const e=this.getAffector();if(e)return e.colorOperation;throw new Error("Invalid affector in ParticleSystemComponent::get colorAffectorOperation")}set colorAffectorOperation(e){const t=this.getAffector();if(t)t.colorOperation=e;else throw new Error("Invalid affector in ParticleSystemComponent::set colorAffectorOperation")}get colorAffectorColors(){const e=this.getAffector();if(e){const a=[];for(let n=0;n<e.colorMap.size();++n){const i=e.colorMap.get(n);a.push({time:i.get(0),color:new t.Color(i.get(1),i.get(2),i.get(3),i.get(4))})}return a}throw new Error("Invalid affector in ParticleSystemComponent::get colorAffectorColors")}set colorAffectorColors(e){const a=this.getAffector();if(a){const n=new t.Vector;for(const a of e){const e=new t.FloatVector;e.pushBack(a.time),e.pushBack(a.color.r),e.pushBack(a.color.g),e.pushBack(a.color.b),e.pushBack(a.color.a),n.pushBack(e)}a.colorMap=n}else throw new Error("Invalid affector in ParticleSystemComponent::set colorAffectorColors")}}A.nativeClasses=["ParticleComponent"];const E=["type","mass","category","mask"],k=16;class L extends n{constructor(e,t){e?(super(e,"RigidBody3D"),this.initialize(t,this.getProps())):super()}initialize(e,t){var a,n;e&&t&&super.initialize(e,t),this.native.initPosition=null==(a=this.entity)?void 0:a.position,this.native.initRotation=null==(n=this.entity)?void 0:n.rotationQuat,this.moveToLocation(this.native.initPosition,this.native.initRotation)}moveToLocation(e,t){this.native.position=e,this.native.rotationQuat=t}getProps(){return E}getContactPoints(e){const t=[];for(let a=0;a<e.contacts.size();++a)t.push(e.contacts.get(a));return t}get mass(){return this.native.mass}set mass(e){this.native.mass=e}setSensorEnabled(e){this.native.sensor=e}get type(){return this.native.rigidBodyType}set type(e){this.native.rigidBodyType=e}get category(){return Math.log2(this.native.categoryBits)}set category(e){this.native.categoryBits=1<<e}get mask(){const e=[],t=this.native.maskBits;for(let a=0;a<k;++a)0<(1<<a&t)&&e.push(a);return e}set mask(e){let t=0;for(const a of e)if(0<=a&&a<k)t|=1<<a;else throw new Error("Invalid mask value!");this.native.maskBits=t}}L.nativeClasses=["RigidBody3D"];const N=["angularDamping","angularFactor","angularVelocity","linearDamping","linearFactor","linearVelocity","gravityAcceleration"];class b extends L{constructor(e,t){e?(super(e,t),this.registerCallbacks()):super()}static fromNative(e,a){const n=new b;if(a instanceof t.RigidBody3D&&!a.sensor)n.initWithNative(e,a,"RigidBody3D");else throw new Error("Incorrect argument to RigidBodyComponent::fromNative");return n.registerCallbacks(),n}destroy(){this.removeCallbacks(),super.destroy()}getProps(){const e=super.getProps();return e.concat(N)}initialize(e,t){super.initialize(e,t),this.reset()}reset(){const e=new g(0,0,0);this.native.initLinearVel=e,this.native.initAngularVel=e,this.native.externalForce=e,this.native.forcePosition=e,this.native.externalTorque=e,this.native.externalImpulse=e,this.native.impulsePosition=e,this.native.externalTorqueImpulse=e,this.linearVelocity=e,this.angularVelocity=e,this.gravityAcceleration=new g(0,-9.81,0)}teleport(e,t){const a=new R;t&&a.eulerAngles(t.x,t.y,t.z),this.moveToLocation(e,a),this.reset()}applyForce(e,t){this.native.externalForce=e,this.native.forcePosition=t?t:new g(0,0,0)}applyTorque(e){this.native.externalTorque=e}applyImpusle(e,t){this.native.externalImpulse=e,this.native.impulsePosition=t?t:new g(0,0,0)}applyTorqueImpulse(e){this.native.externalTorqueImpulse=e}get angularDamping(){return this.native.angularDamping}set angularDamping(e){this.native.angularDamping=e}get angularFactor(){return this.native.angularFactor}set angularFactor(e){this.native.angularFactor=e}get angularVelocity(){return this.native.angularVel}set angularVelocity(e){this.native.angularVel=e}get linearDamping(){return this.native.linearDamping}set linearDamping(e){this.native.linearDamping=e}get linearFactor(){return this.native.linearFactor}set linearFactor(e){this.native.linearFactor=e}get linearVelocity(){return this.native.linearVel}set linearVelocity(e){this.native.linearVel=e}get gravityAcceleration(){return this.native.gravityAcceleration}set gravityAcceleration(e){this.native.gravityAcceleration=e}registerCallbacks(){this.addListener(t.Collision3DEventType.ENTER,this.onCollisionEnter,this),this.addListener(t.Collision3DEventType.STAY,this.onCollisionStay,this),this.addListener(t.Collision3DEventType.EXIT,this.onCollisionExit,this)}removeCallbacks(){this.removeListener(t.Collision3DEventType.ENTER,this.onCollisionEnter),this.removeListener(t.Collision3DEventType.STAY,this.onCollisionStay),this.removeListener(t.Collision3DEventType.EXIT,this.onCollisionExit)}onCollisionEnter(e,t){if(t&&t.otherRigidbody){var a,n;const i=t.otherRigidbody.entity,r=null==(a=e.entity)||null==(n=a.scene)?void 0:n.entityFromNative(i),o=e.getContactPoints(t);t.otherRigidbody.sensor?e.fire("triggerenter",e.entity,r,o):e.fire("collisionenter",e.entity,r,o)}}onCollisionStay(e,t){if(t&&t.otherRigidbody){var a,n;const i=t.otherRigidbody.entity,r=null==(a=e.entity)||null==(n=a.scene)?void 0:n.entityFromNative(i),o=e.getContactPoints(t);t.otherRigidbody.sensor?e.fire("triggerstay",e.entity,r,o):e.fire("collisionstay",e.entity,r,o)}}onCollisionExit(e,t){if(t&&t.otherRigidbody){var a,n;const i=t.otherRigidbody.entity,r=null==(a=e.entity)||null==(n=a.scene)?void 0:n.entityFromNative(i),o=e.getContactPoints(t);t.otherRigidbody.sensor?e.fire("triggerexit",e.entity,r,o):e.fire("collisionexit",e.entity,r,o)}}}const D=["alpha","alphaCascading"];class B extends n{constructor(e,t,a){if(!(e&&t))super();else if(e.screenTransform)super(e,t),this.initialize(a,this.getProps());else throw new Error("Widget2DComponent can only be added to an 2d entity")}getProps(){return D}get alpha(){return this.native.alpha}set alpha(e){this.native.alpha=e}get alphaCascading(){return this.native.cascadeAlphaEnabled}set alphaCascading(e){this.native.cascadeAlphaEnabled=e}}const w=["renderMode","color","texture","atlas","atlasIndex","filledType","filledStart","filledRange","slicedLeft","slicedRight","slicedTop","slicedBottom","slicedFillCenter","ellipseWidth","ellipseHeight","freeTopLeft","freeTopRight","freeBottomLeft","freeBottomRight","cornerTopLeft","cornerTopRight","cornerBottomLeft","cornerBottomRight"];class O extends B{constructor(e,t){super(e,"IFSprite2d",t)}static fromNative(e,a){const n=new O;if(a instanceof t.IFSprite2d)n.initWithNative(e,a,"IFSprite2d");else throw new Error("Incorrect argument in ImageComponent::fromNative");return n}getProps(){const e=super.getProps();return e.concat(w)}get renderMode(){return this.native.type}set renderMode(e){this.native.type=e}get color(){return this.native.colorTint}set color(e){this.native.colorTint=e}get texture(){return this.native.texture}set texture(e){this.native.texture=e}get atlas(){return this.native.imageAtlas}set atlas(e){this.native.imageAtlas=e}get atlasIndex(){return this.native.atlasIndex}set atlasIndex(e){this.native.atlasIndex=e}get filledType(){return this.native.filledType}set filledType(e){this.native.filledType=e}get filledStart(){return this.native.filledStartPos}set filledStart(e){this.native.filledStartPos=e}get filledRange(){return this.native.filledRange}set filledRange(e){this.native.filledRange=e}get slicedLeft(){return this.native.slicedLeft}set slicedLeft(e){this.native.slicedLeft=e}get slicedRight(){return this.native.slicedRight}set slicedRight(e){this.native.slicedRight=e}get slicedTop(){return this.native.slicedTop}set slicedTop(e){this.native.slicedTop=e}get slicedBottom(){return this.native.slicedBottom}set slicedBottom(e){this.native.slicedBottom=e}get slicedFillCenter(){return this.native.fillCenter}set slicedFillCenter(e){this.native.fillCenter=e}get ellipseWidth(){return this.native.ellipseX}set ellipseWidth(e){this.native.ellipseX=e}get ellipseHeight(){return this.native.ellipseY}set ellipseHeight(e){this.native.ellipseY=e}get freeTopLeft(){return this.native.topLeftPoint}set freeTopLeft(e){this.native.topLeftPoint=e}get freeTopRight(){return this.native.topRightPoint}set freeTopRight(e){this.native.topRightPoint=e}get freeBottomLeft(){return this.native.bottomLeftPoint}set freeBottomLeft(e){this.native.bottomLeftPoint=e}get freeBottomRight(){return this.native.bottomRightPoint}set freeBottomRight(e){this.native.bottomRightPoint=e}get cornerTopLeft(){return this.native.topLeft}set cornerTopLeft(e){this.native.topLeft=e}get cornerTopRight(){return this.native.topRight}set cornerTopRight(e){this.native.topRight=e}get cornerBottomLeft(){return this.native.bottomLeft}set cornerBottomLeft(e){this.native.bottomLeft=e}get cornerBottomRight(){return this.native.bottomRight}set cornerBottomRight(e){this.native.bottomRight=e}}O.nativeClasses=["IFSprite2d"];const z=["blendMode","alpha","alphaBlending","mask","clipping"];class V extends n{constructor(e,t){if(!e)super();else if(e.screenTransform)super(e,"IFLayer2d"),t||(t={}),t&&!t.hasOwnProperty("alphaBlending")&&(t.alphaBlending=!0),this.initialize(t,this.getProps());else throw new Error("CanvasComponent can only be added to an 2d entity")}static fromNative(e,a){const n=new V;if(a instanceof t.IFLayer2d)n.initWithNative(e,a,"IFLayer2d");else throw new Error("Incorrect argument to CanvasComponent::fromNative");return n}getProps(){return z}get blendMode(){return this.native.blendMode}set blendMode(e){this.native.blendMode=e}get maskType(){return this.native.maskType}set maskType(e){this.native.maskType=e}get renderOrder(){return this.native.renderOrderMode}set renderOrder(e){this.native.renderOrderMode=e}get alpha(){return this.native.blendAlpha}set alpha(e){this.native.blendAlpha=e}get clipping(){return this.native.scissorRectMask}set clipping(e){this.native.scissorRectMask=e}get alphaBlending(){return this.native.blendAlphaCkeck}set alphaBlending(e){this.native.blendAlphaCkeck=e}getDrawCallCount(){return this.native.drawCallNum}}V.nativeClasses=["IFLayer2d"];const H=["renderMode","pivot","flipX","flipY ","material","color"];class U extends n{constructor(e,t){e?(super(e,"Sprite2DRenderer"),this.initialize(t,this.getProps())):super()}static fromNative(e,a){const n=new U;if(a instanceof t.Sprite2DRenderer)n.initWithNative(e,a,"Sprite2DRenderer");else throw new Error("Incorrect argument in SpriteComponent::fromNative");return n}getProps(){return H}get material(){if(!this._material){const e=this.native.material;e&&(this._material=new I(e))}return this._material}set material(e){e&&(this._material=e,this.native.material=e.native)}get flipX(){return this.native.mirror}set flipX(e){this.native.mirror=e}get flipY(){return this.native.flip}set flipY(e){this.native.flip=e}get color(){return this.native.color}set color(e){this.native.color=e}get pivot(){return this.native.pivot}set pivot(e){this.native.pivot=e}get renderMode(){return this.native.stretchMode}set renderMode(e){this.native.stretchMode=e}setBaseTexture(e,a,n){a===void 0&&(a=new S(1,1,0,0)),n===void 0&&(n=t.RotateType.ROTATE_0),this.native.setBaseTexture(e,a,n)}}U.nativeClasses=["Sprite2DRenderer"];const G=["sequence","textureName","autoPlay","playMode"];class W extends n{constructor(e,t){e?(super(e,"AnimSeqComponent"),this.initialize(t,this.getProps())):super()}static fromNative(e,a){const n=new W;if(a instanceof t.AnimSeqComponent)n.initWithNative(e,a,"AnimSeqComponent");else throw new Error("Incorrect argument in SeqAnimationComponent::fromNative");return n}getProps(){return G}play(){this.native.play()}stop(){this.native.stop()}pause(){this.native.pause()}resume(){this.native.play()}seek(e){this.native.seek(e)}get sequence(){return this.native.animSeq}set sequence(e){this.native.animSeq=e}get textureName(){return this.native.texName}set textureName(e){this.native.texName=e}get autoPlay(){return this.native.autoplay}set autoPlay(e){this.native.autoplay=e}get playMode(){return this.native.playmode}set playMode(e){this.native.playmode=e}}W.nativeClasses=["AnimSeqComponent"];class q extends L{constructor(e,t){if(e){const a={type:exports.Physics3DType.Kinematic,mass:1};t&&(a.category=t.category,a.mask=t.mask),super(e,a),this.setSensorEnabled(!0),this.registerCallbacks()}else super()}static fromNative(e,a){const n=new q;if(a instanceof t.RigidBody3D&&a.sensor)n.initWithNative(e,a,"RigidBody3D");else throw new Error("Incorrect argument to TriggerComponent::fromNative");return n.registerCallbacks(),n}destroy(){this.removeCallbacks(),super.destroy()}registerCallbacks(){this.addListener(t.Collision3DEventType.ENTER,this.onTriggerEnter,this),this.addListener(t.Collision3DEventType.STAY,this.onTriggerStay,this),this.addListener(t.Collision3DEventType.EXIT,this.onTriggerExit,this)}removeCallbacks(){this.removeListener(t.Collision3DEventType.ENTER,this.onTriggerEnter),this.removeListener(t.Collision3DEventType.STAY,this.onTriggerStay),this.removeListener(t.Collision3DEventType.EXIT,this.onTriggerExit)}onTriggerEnter(e,t){if(t&&t.otherRigidbody){var a,n;const i=t.otherRigidbody.entity,r=null==(a=e.entity)||null==(n=a.scene)?void 0:n.entityFromNative(i),o=e.getContactPoints(t);e.fire("triggerenter",e.entity,r,o)}}onTriggerStay(e,t){if(t&&t.otherRigidbody){var a,n;const i=t.otherRigidbody.entity,r=null==(a=e.entity)||null==(n=a.scene)?void 0:n.entityFromNative(i),o=e.getContactPoints(t);e.fire("triggerstay",e.entity,r,o)}}onTriggerExit(e,t){if(t&&t.otherRigidbody){var a,n;const i=t.otherRigidbody.entity,r=null==(a=e.entity)||null==(n=a.scene)?void 0:n.entityFromNative(i),o=e.getContactPoints(t);e.fire("triggerexit",e.entity,r,o)}}}const Y=["touchEnabled"];class j extends n{constructor(e,t,a){if(!(e&&t))super();else if(e.screenTransform)super(e,t),this.initialize(a,this.getProps());else throw new Error("UIInteractComponent can only be added to an 2d entity")}getProps(){return Y}get touchEnabled(){return this.native.touchEnabled}set touchEnabled(e){this.native.touchEnabled=e}}const K=["enabled","normalFrame","pressedFrame","disabledFrame","normalColor","pressedColor","disabledColor"];class X extends j{constructor(e,t,a){e&&t?super(e,t,a):super()}getProps(){const e=super.getProps();return e.concat(K)}get enabled(){return this.native.enabled}set enabled(e){this.native.enabled=e}get normalFrame(){return this.native.normalSprite}set normalFrame(e){this.native.normalSprite=e}get pressedFrame(){return this.native.pressedSprite}set pressedFrame(e){this.native.pressedSprite=e}get disabledFrame(){return this.native.disabledSprite}set disabledFrame(e){this.native.disabledSprite=e}get normalColor(){return this.native.normalColor}set normalColor(e){this.native.normalColor=e}get pressedColor(){return this.native.pressedColor}set pressedColor(e){this.native.pressedColor=e}get disabledColor(){return this.native.disabledColor}set disabledColor(e){this.native.disabledColor=e}}var Q;(function(e){e[e.TouchDown=1201]="TouchDown",e[e.TouchDownRepeat=1202]="TouchDownRepeat",e[e.DragInside=1204]="DragInside",e[e.DragOutside=1208]="DragOutside",e[e.DragEnter=1216]="DragEnter",e[e.DragExit=1232]="DragExit",e[e.TouchUpInside=1264]="TouchUpInside",e[e.TouchUpOutside=1328]="TouchUpOutside",e[e.TouchCancel=1456]="TouchCancel"})(Q||(Q={}));const J=[];class Z extends X{constructor(e,t){e?(super(e,"IFUIButton",t),this.registerCallbacks()):super()}destroy(){this.removeCallbacks(),super.destroy()}static fromNative(e,a){const n=new Z;if(a instanceof t.IFUIButton)n.initWithNative(e,a,"IFButton2d");else throw new Error("Incorrect argument to ButtonComponent::fromNative");return n.registerCallbacks(),n}getProps(){const e=super.getProps();return e.concat(J)}registerCallbacks(){this.addListener(Q.TouchDown,this.onClicked,this)}removeCallbacks(){this.removeListener(Q.TouchDown,this.onClicked)}onClicked(e){e.fire("click",e.entity)}}Z.nativeClasses=["IFUIButton"];const $=["mask"];class ee extends n{constructor(e,t){if(!e)super();else if(e.camera)super(e,"IFEventDistributor"),this.initialize(t,this.getProps());else throw new Error("UIEventSystemComponent can only be added to an camera entity")}static fromNative(e,a){const n=new ee;if(a instanceof t.IFEventDistributor)n.initWithNative(e,a,"IFEventDistributor");else throw new Error("Incorrect argument to UIEventSystemComponent::fromNative");return n}getProps(){return $}get mask(){return this.native.EventMask}set mask(e){this.native.EventMask=e}}ee.nativeClasses=["IFEventDistributor"];const te=["autoSize","center","size"],ae=new Map([[exports.UIColliderType.Box,"IFBoxCollider"]]);function ne(e){if(!ae.has(e))throw new Error("Unknown type of collider");return ae.get(e)}class ie extends n{constructor(e,t){if(!e)super();else if(e.screenTransform&&t&&t.hasOwnProperty("type"))super(e,ne(t.type)),this.initialize(t,this.getProps());else throw new Error("UIColliderComponent can only be added to an 2d entity with the type option specified")}static fromNative(e,a){const n=new ie;if(a instanceof t.IFBoxCollider)n.initWithNative(e,a,"IFBoxCollider"),n.type=exports.UIColliderType.Box;else throw new Error("Incorrect argument to UIColliderComponent::fromNative");return n}getProps(){return te}get autoSize(){return this.native.autoAdjustCollider}set autoSize(e){this.native.autoAdjustCollider=e}get center(){return this.native.center}set center(e){this.native.center=e}get size(){return this.native.size}set size(e){this.native.size=e}}ie.nativeClasses=["IFBoxCollider"];const re=["fillEntity","thumbEntity","mode","direction","minValue","maxValue","step","value"],oe=1004;class se extends X{constructor(e,t){e?(super(e,"IFUISlider",t),this.registerCallbacks()):super()}destroy(){this.removeCallbacks(),super.destroy()}static fromNative(e,a){const n=new se;if(a instanceof t.IFUISlider)n.initWithNative(e,a,"IFSlider2d");else throw new Error("Incorrect argument to SliderComponent::fromNative");return n.registerCallbacks(),n}getProps(){const e=super.getProps();return e.concat(re)}registerCallbacks(){this.addListener(oe,this.onValueChanged,this)}removeCallbacks(){this.removeListener(oe,this.onValueChanged)}onValueChanged(e){e.fire("change",e.entity)}get mode(){return this.native.mode}set mode(e){this.native.mode=e}get direction(){return this.native.direction}set direction(e){this.native.direction=e}get minValue(){return this.native.minValue}set minValue(e){this.native.minValue=e}get maxValue(){return this.native.maxValue}set maxValue(e){this.native.maxValue=e}get step(){return this.native.steps}set step(e){this.native.steps=e}get value(){return this.native.value}set value(e){this.native.value=e}set fillEntity(e){if(e.native)this.native.fillTrans=e.native.getComponent("IFTransform2d");else throw new Error("Invalid fillEntity!")}set thumbEntity(e){if(e.native)this.native.thumbTrans=e.native.getComponent("IFTransform2d");else throw new Error("Invalid thumbEntity!")}}se.nativeClasses=["IFUISlider"];const de=[];class le extends X{constructor(e,t){e?(super(e,"IFUISliderThumb",t),this.registerCallbacks()):super()}destroy(){this.removeCallbacks(),super.destroy()}static fromNative(e,a){const n=new le;if(a instanceof t.IFUISliderThumb)n.initWithNative(e,a,"IFSliderThumb2d");else throw new Error("Incorrect argument to SliderThumbComponent::fromNative");return n}getProps(){const e=super.getProps();return e.concat(de)}registerCallbacks(){this.addListener(Q.TouchDown,this.onClicked,this)}removeCallbacks(){this.removeListener(Q.TouchDown,this.onClicked)}onClicked(e){e.fire("click",e.entity)}}le.nativeClasses=["IFUISliderThumb"];const ce=["text","textColor","fontPath","fontSize","fontType","alignment","fitType","spacing"];class pe extends B{constructor(e,t){e?super(e,"IFUILabel",t):super()}static fromNative(e,a){const n=new pe;if(a instanceof t.IFUILabel)n.initWithNative(e,a,"IFUILabel");else throw new Error("Incorrect argument to LabelComponent::fromNative");return n}getProps(){const e=super.getProps();return e.concat(ce)}get text(){return this.native.text}set text(e){this.native.text=e}get textColor(){return this.native.textColor}set textColor(e){this.native.textColor=e}get fontPath(){return this.native.fontPath}set fontPath(e){this.native.fontPath=e}get fontSize(){return this.native.fontSize}set fontSize(e){this.native.fontSize=e}get fontType(){return this.native.fontType}set fontType(e){this.native.fontType=e}get alignment(){return this.native.alignment}set alignment(e){this.native.alignment=e}get fitType(){return this.native.fitType}set fitType(e){this.native.fitType=e}get spacing(){return this.native.spacing}set spacing(e){this.native.spacing=e}}pe.nativeClasses=["IFUILabel"];const ue=["type","size"];class me extends n{constructor(e,t){if(!e)super();else if(e.screenTransform)super(e,"IFCanvas2d"),this.initialize(t,this.getProps());else throw new Error("Canvas2DComponent can only be added to an 2d entity")}static fromNative(e,a){const n=new me;if(a instanceof t.IFCanvas2d)n.initWithNative(e,a,"IFCanvas2d");else throw new Error("Incorrect argument to Canvas2DComponent::fromNative");return n}getProps(){return ue}get type(){return this.native.resolutionType}set type(e){this.native.resolutionType=e}get size(){return this.native.resolutionSize}set size(e){this.native.resolutionSize=e}}me.nativeClasses=["IFCanvas2d"];const ge=["type","sizeMode","gridMode","verticalDirection","horizontalDirection","sortMode","cellSize","paddingLeft","paddingRight","paddingTop","paddingBottom","horizontalSpace","verticalSpace","useScaledSize","excludeInvisible"];class _e extends n{constructor(e,t){if(!e)super();else if(e.screenTransform)super(e,"IFUIGrid"),this.initialize(t,this.getProps());else throw new Error("LayoutComponent can only be added to an 2d entity")}static fromNative(e,a){const n=new _e;if(a instanceof t.IFUIGrid)n.initWithNative(e,a,"IFUIGrid");else throw new Error("Incorrect argument to LayoutComponent::fromNative");return n}getProps(){return ge}get type(){return this.native.type}set type(e){this.native.type=e}get sizeMode(){return this.native.resizeMode}set sizeMode(e){this.native.resizeMode=e}get gridMode(){return this.native.startAxis}set gridMode(e){this.native.startAxis=e}get verticalDirection(){return this.native.verticalDirection}set verticalDirection(e){this.native.verticalDirection=e}get horizontalDirection(){return this.native.horizontalDirection}set horizontalDirection(e){this.native.horizontalDirection=e}get sortMode(){return this.native.sortingType}set sortMode(e){this.native.sortingType=e}get cellSize(){return this.native.cellSize}set cellSize(e){this.native.cellSize=e}get paddingLeft(){return this.native.paddingLeft}set paddingLeft(e){this.native.paddingLeft=e}get paddingRight(){return this.native.paddingRight}set paddingRight(e){this.native.paddingRight=e}get paddingTop(){return this.native.paddingTop}set paddingTop(e){this.native.paddingTop=e}get paddingBottom(){return this.native.paddingBottom}set paddingBottom(e){this.native.paddingBottom=e}get horizontalSpace(){return this.native.horizontalSpace}set horizontalSpace(e){this.native.horizontalSpace=e}get verticalSpace(){return this.native.verticalSpace}set verticalSpace(e){this.native.verticalSpace=e}get useScaledSize(){return this.native.affectedByScale}set useScaledSize(e){this.native.affectedByScale=e}get excludeInvisible(){return this.native.filterInvisibleChildren}set excludeInvisible(e){this.native.filterInvisibleChildren=e}}_e.nativeClasses=["IFUIGrid"];const fe=["target","leftTarget","rightTarget","topTarget","bottomTarget","leftAnchor","rightAnchor","topAnchor","bottomAnchor","leftOffset","rightOffset","topOffset","bottomOffset"];class he extends n{constructor(e,t){if(!e)super();else if(e.screenTransform)super(e,"IFUIConstraints"),this.initialize(t,this.getProps());else throw new Error("AlignmentComponent can only be added to an 2d entity")}static fromNative(e,a){const n=new he;if(a instanceof t.IFUIConstraints)n.initWithNative(e,a,"IFUIConstraints");else throw new Error("Incorrect argument to AlignmentComponent::fromNative");return n}getProps(){return fe}set target(e){if(e.native)this.native.target=e.native.getComponent("IFTransform2d");else throw new Error("Invalid target")}set leftTarget(e){if(e.native)this.native.leftTarget=e.native.getComponent("IFTransform2d");else throw new Error("Invalid leftTarget!")}set rightTarget(e){if(e.native)this.native.rightTarget=e.native.getComponent("IFTransform2d");else throw new Error("Invalid rightTarget!")}set bottomTarget(e){if(e.native)this.native.bottomTarget=e.native.getComponent("IFTransform2d");else throw new Error("Invalid bottomTarget!")}set topTarget(e){if(e.native)this.native.topTarget=e.native.getComponent("IFTransform2d");else throw new Error("Invalid topTarget!")}get leftAnchor(){return this.native.leftRange}set leftAnchor(e){this.native.leftRange=e}get rightAnchor(){return this.native.rightRange}set rightAnchor(e){this.native.rightRange=e}get topAnchor(){return this.native.topRange}set topAnchor(e){this.native.topRange=e}get bottomAnchor(){return this.native.bottomRange}set bottomAnchor(e){this.native.bottomRange=e}get leftOffset(){return this.native.leftOffset}set leftOffset(e){this.native.leftOffset=e}get rightOffset(){return this.native.rightOffset}set rightOffset(e){this.native.rightOffset=e}get topOffset(){return this.native.topOffset}set topOffset(e){this.native.topOffset=e}get bottomOffset(){return this.native.bottomOffset}set bottomOffset(e){this.native.bottomOffset=e}}he.nativeClasses=["IFUIConstraints"];const ye=["otherEntity","linearLowerLimit","linearUpperLimit","angularLowerLimit","angularUpperLimit","positionOffset","otherPositionOffset","rotationOffset","otherRotationOffset","linearCorrection","linearSoftness","angularCorrection","angularSoftness"];class ve extends n{constructor(e,t){e?(super(e,"GenericJoint3D"),this.initialize(t,this.getProps())):super()}static fromNative(e,a){const n=new ve;if(a instanceof t.GenericJoint3D)n.initWithNative(e,a,"GenericJoint3D");else throw new Error("Incorrect argument to GenericJoint3DComponent::fromNative");return n}getProps(){return ye}set otherEntity(e){if(e.native)this.native.connectedBody=e.native.getComponent("RigidBody3D");else throw new Error("Invalid target")}set linearLowerLimit(e){this.native.linearLowerLimit=e}get linearLowerLimit(){return this.native.linearLowerLimit}set linearUpperLimit(e){this.native.linearUpperLimit=e}get linearUpperLimit(){return this.native.linearUpperLimit}set angularLowerLimit(e){this.native.angularLowerLimit=e}get angularLowerLimit(){return this.native.angularLowerLimit}set angularUpperLimit(e){this.native.angularUpperLimit=e}get angularUpperLimit(){return this.native.angularUpperLimit}set positionOffset(e){this.native.posAnchorA=e}get positionOffset(){return this.native.posAnchorA}set otherPositionOffset(e){this.native.posAnchorB=e}get otherPositionOffset(){return this.native.posAnchorB}set rotationOffset(e){this.native.rotAnchorA=e}get rotationOffset(){return this.native.rotAnchorA}set otherRotationOffset(e){this.native.rotAnchorB=e}get otherRotationOffset(){return this.native.rotAnchorB}set linearCorrection(e){this.native.erpLinear=e}get linearCorrection(){return this.native.erpLinear}set linearSoftness(e){this.native.cfmLinear=e}get linearSoftness(){return this.native.cfmLinear}set angularCorrection(e){this.native.erpAngular=e}get angularCorrection(){return this.native.erpAngular}set angularSoftness(e){this.native.cfmAngular=e}get angularSoftness(){return this.native.cfmAngular}}ve.nativeClasses=["GenericJoint3D"];const Te=["animations"];class Se extends n{constructor(e,t){e?(super(e,"Animator"),this.initialize(t,this.getProps())):super()}static fromNative(e,a){const n=new Se;if(a instanceof t.Animator)n.initWithNative(e,a,"Animator");else throw new Error("Incorrect argument in AnimationComponent::fromNative");return n}getProps(){return Te}play(e,t){const a={playMode:t&&t.playMode!==void 0?t.playMode:exports.AnimationPlayMode.Once,speed:t&&t.speed!==void 0?t.speed:1,fadeTime:t&&t.fadeTime!==void 0?t.fadeTime:0,startTime:t&&t.startTime!==void 0?t.startTime:0};this.native.play(e,a.playMode,a.speed,a.fadeTime,a.startTime)}stop(){this.native.stopAllAnimations()}pause(){this.native.pauseAnimator()}resume(){this.native.resumeAnimator()}get animations(){const e=[],t=this.native.animations;for(let a=0;a<t.size();a++)e.push(t.get(a));return e}set animations(e){const a=new t.Vector;for(const t of e)a.pushBack(t);this.native.animations=a}}Se.nativeClasses=["Animator"];const Ce=["audio","autoPlay","loop"];class Ie extends n{constructor(e,t){e?(super(e,"Audio"),this.initialize(t,this.getProps())):super()}static fromNative(e,a){const n=new Ie;if(a instanceof t.Audio)n.initWithNative(e,a,"Audio");else throw new Error("Incorrect argument in AudioComponent::fromNative");return n}getProps(){return Ce}get audio(){return this.native.clip}set audio(e){this.native.clip=e}get autoPlay(){return this.native.playOnAwake}set autoPlay(e){this.native.playOnAwake=e}get loop(){return this.native.loop}set loop(e){this.native.loop=e}play(){this.native.play()}stop(){this.native.stop()}pause(){this.native.pause()}resume(){this.native.resume()}reset(){this.native.reset()}}Ie.nativeClasses=["Audio"];const xe=["position","rotation","scale","size","pivot","flipX","flipY"];class Pe extends n{constructor(e,t){e?(super(e,"IFTransform2d"),this.initialize(t,this.getProps())):super()}static fromNative(e,a){const n=new Pe;if(a instanceof t.IFTransform2d)n.initWithNative(e,a,"IFTransform2d");else throw new Error("Incorrect argument in ScreenTransformComponent::fromNative");return n}getProps(){return xe}get position(){return this.native.position}set position(e){this.native.position=e}get scale(){return this.native.scale}set scale(e){this.native.scale=e}get rotation(){return this.native.rotation}set rotation(e){this.native.rotation=e}get size(){return this.native.size}set size(e){this.native.size=e}get pivot(){return this.native.pivot}set pivot(e){this.native.pivot=e}get flipX(){return this.native.flipX}set flipX(e){this.native.flipX=e}get flipY(){return this.native.flipY}set flipY(e){this.native.flipY=e}}Pe.nativeClasses=["IFTransform2d"];class Me extends n{constructor(e,t){if(super(),e){const a=e.native.addJsScriptComponent(null==t?void 0:t.scriptPath);this.initWithNative(e,a,"JSScriptComponent")}}static fromNative(e,t){const a=new Me;return a.initWithNative(e,t,"JSScriptComponent"),a}get script(){return this.native.getScript().ref}}Me.nativeClasses=["JSScriptComponent"];const Re=["type","layer"];class Fe extends n{constructor(e,t){e?(super(e,"Raycaster"),this.initialize(t,this.getProps())):super()}static fromNative(e,a){const n=new Fe;if(a instanceof t.Raycaster)n.initWithNative(e,a,"Raycaster");else throw new Error("Incorrect argument in ScreenRaycasterComponent::fromNative");return n}getProps(){return Re}get type(){return this.native.raycasterType}set type(e){this.native.raycasterType=e}get layers(){const e=[];for(let t=0;t<r;++t)this.native.layer.test(t)&&e.push(t);return e}set layers(e){const a=new t.DynamicBitset(r,0);for(const t of e)if(0<=t&&t<r)a.set(t);else throw new Error("Invalid layer value!");this.native.layer=a}raycastOBB(e){var t;if(null!=(t=this.entity)&&t.camera){const t=[],n=this.native.raycast3D(e);for(let e=0;e<n.size();e++){var a;const i=null==(a=this.entity.scene)?void 0:a.entityFromNative(n.get(e).entity);i&&t.push(i)}return t}throw new Error("No CameraComponent attached on the entity!")}raycastUI(e){var t;if(null!=(t=this.entity)&&t.camera){const t=[],n=this.native.raycastIF(e);for(let e=0;e<n.size();e++){var a;const i=null==(a=this.entity.scene)?void 0:a.entityFromNative(n.get(e).entity);i&&t.push(i)}return t}throw new Error("No CameraComponent attached on the entity!")}raycastGeometricPlane(e,t){var a;if(null!=(a=this.entity)&&a.camera){const a=new g(t.x,t.y,t.z),n=t.w,i=this.native.viewPointHitPlane(e,a,n);let r=!0;return 9999<i.x&&9999<i.y&&9999<i.z&&(r=!1),{hit:r,hitpos:i}}throw new Error("No CameraComponent attached on the entity!")}}Fe.nativeClasses=["Raycaster"];class Ae extends e{constructor(e,a){if(super(),this._components=new Map,e&&e instanceof Ee&&a&&a instanceof t.Entity)this.scene=e,this.native=a,this._transform=this.native.getComponent("Transform"),this.scene.addEntityToCache(this);else{var n;if(null!=a&&a.scene)this.scene=null==a?void 0:a.scene;else{var i;this.scene=null==(i=Ua.engine)?void 0:i.scene}if(!this.scene)throw new Error("No active scene found!");const r=e&&"string"==typeof e?e:"Untitled";this.native=this.scene.native.createEntity(r),a&&!(a instanceof t.Entity)&&(this.layer=a.layer?a.layer:0,this.tags=a.tags?a.tags:[]),this._transform=this.native.addComponent("Transform"),null==(n=this.scene)?void 0:n.addEntityToCache(this)}}static fromNative(e,a){if(a instanceof t.Entity)return new Ae(e,a);throw new Error("Incorrect argument to Entity::fromNative")}get name(){return this.native.name}set name(e){this.native.name=e}get parent(){var e;let t;return this._transform&&this._transform.parent&&(t=this._transform.parent.entity),null==(e=this.scene)?void 0:e.entityFromNative(t)}get enabled(){return this.native.selfvisible}set enabled(e){this.native.visible=e}get enabledInScene(){return this.native.visible}get layer(){return this.native.layer}set layer(e){if(0<=e&&e<r)this.native.layer=e;else throw new Error("Invalid layer value!")}get tags(){const e=[],t=this.native.tag;for(let a=0;a<o;++a)t&1<<a&&e.push(a);return e}set tags(e){let t=0;for(const a of e)if(0<=a&&a<o)t|=1<<a;else throw new Error(`Invalid tag value: ${a}`);this.native.tag=t}get screenTransform(){return this.getComponent(Pe)}get camera(){return this.getComponent(d)}get model(){return this.getComponent(P)}get light(){return this.getComponent(y)}get rigidBody(){return this.getComponent(b)}get trigger(){return this.getComponent(q)}get collider(){return this.getComponent(u)}get particleSystem(){return this.getComponent(A)}get sprite(){return this.getComponent(U)}get image(){return this.getComponent(O)}get canvas(){return this.getComponent(V)}get canvasScaler(){return this.getComponent(me)}get button(){return this.getComponent(Z)}get uiEventSystem(){return this.getComponent(ee)}get uiCollider(){return this.getComponent(ie)}get slider(){return this.getComponent(se)}get sliderThumb(){return this.getComponent(le)}get label(){return this.getComponent(pe)}get seqAnimation(){return this.getComponent(W)}get layout(){return this.getComponent(_e)}get alignment(){return this.getComponent(he)}get genericJoint(){return this.getComponent(ve)}get animation(){return this.getComponent(Se)}get audio(){return this.getComponent(Ie)}get custom(){return this.getComponent(Me)}get screenRaycaster(){return this.getComponent(Fe)}addComponent(e,t){const a=this._addComponent(e,t);if(a){const e=a.native.handle;return this._components.has(e)?(a.entity=void 0,a.native=void 0,a.destroy(),this._components.get(e)):(this._components.set(e,a),a)}}_addComponent(e,t){switch(e){case"ScreenTransform":if(!this.getComponent(Pe)){this.native.removeComponent("Transform");const e=new Pe(this,t);return this._transform=e.native,e}throw new Error(`Entity already has ScreenTransform component`);case"Camera":return new d(this,t);case"Model":return new P(this,t);case"Light":return new y(this,t);case"RigidBody3D":return new b(this,t);case"Trigger3D":return new q(this,t);case"Collider3D":return new u(this,t);case"ParticleSystem":return new A(this,t);case"Sprite":return new U(this,t);case"Image":return new O(this,t);case"Canvas":return new V(this,t);case"CanvasScaler":return new me(this,t);case"Button":return new Z(this,t);case"UIEventSystem":return new ee(this,t);case"UICollider":return new ie(this,t);case"Slider":return new se(this,t);case"SliderThumb":return new le(this,t);case"Label":return new pe(this,t);case"SeqAnimation":return new W(this,t);case"Layout":return new _e(this,t);case"Alignment":return new he(this,t);case"GenericJoint3D":return new ve(this,t);case"Animation":return new Se(this,t);case"Audio":return new Ie(this,t);case"Custom":return new Me(this,t);case"Raycaster":return new Fe(this,t);default:throw new Error(`Doesn't support component type: ${e}`);}}removeComponent(e){const t=this.getComponentViaStringType(e);return!!t&&(this._components.delete(t.native.handle),t.destroy(),"ScreenTransform"===e&&(this._transform=this.native.addComponent("Transform")),!0)}getComponentViaStringType(e){switch(e){case"ScreenTransform":return this.getComponent(Pe);case"Camera":return this.getComponent(d);case"Model":return this.getComponent(P);case"Light":return this.getComponent(y);case"RigidBody3D":return this.getComponent(b);case"Trigger3D":return this.getComponent(q);case"Collider3D":return this.getComponent(u);case"ParticleSystem":return this.getComponent(A);case"Image":return this.getComponent(O);case"Canvas":return this.getComponent(V);case"CanvasScaler":return this.getComponent(me);case"Sprite":return this.getComponent(U);case"Button":return this.getComponent(Z);case"UIEventSystem":return this.getComponent(ee);case"UICollider":return this.getComponent(ie);case"Slider":return this.getComponent(se);case"SliderThumb":return this.getComponent(le);case"Label":return this.getComponent(pe);case"SeqAnimation":return this.getComponent(W);case"Layout":return this.getComponent(_e);case"Alignment":return this.getComponent(he);case"GenericJoint3D":return this.getComponent(ve);case"Animation":return this.getComponent(Se);case"Audio":return this.getComponent(Ie);case"Custom":return this.getComponent(Me);case"Raycaster":return this.getComponent(Fe);default:throw new Error(`Doesn't support component type: ${e}`);}}addChild(e){this._transform&&this._transform.addTransform(e.native.getComponent("Transform"))}removeChild(e){this._transform&&this._transform.removeTransform(e.native.getComponent("Transform"))}findByName(e){let t;if(this.name===e)t=this;else for(const a of this.children)if(t=a.findByName(e),t)break;return t}findByTag(e){let t;if(this.hasTag(e))t=this;else for(const a of this.children)if(t=a.findByTag(e),t)break;return t}findAllByName(e){const t=[];this.name===e&&t.push(this);for(const a of this.children)t.push(...a.findAllByName(e));return t}findAllByTag(e){const t=[];this.hasTag(e)&&t.push(this);for(const a of this.children)t.push(...a.findAllByTag(e));return t}get position(){return this._transform.localPosition}set position(e){this._transform.localPosition=e}get scale(){return this._transform.localScale}set scale(e){this._transform.localScale=e}get rotation(){return this._transform.localEulerAngle}set rotation(e){this._transform.localEulerAngle=e}get rotationQuat(){return this._transform.localOrientation}set rotationQuat(e){this._transform.localOrientation=e}get worldPosition(){return this._transform.worldPosition}set worldPosition(e){this._transform.worldPosition=e}get worldScale(){return this._transform.worldScale}set worldScale(e){this._transform.worldScale=e}get worldRotation(){return this._transform.worldOrientation}set worldRotation(e){this._transform.worldOrientation=e}get worldEulerAngles(){return this._transform.worldEulerAngle}set worldEulerAngles(e){this._transform.worldEulerAngle=e}addTag(e){if(0<=e&&e<o)this.native.addTag(e);else throw new Error(`Invalid tag:[${e}] number when adding tag. (valid tag: 0-31)`)}hasTag(e){return this.native.hasTag(e)}destroy(){var e,t;for(const e of this._components.values())e.destroy();this._components.clear(),null==(e=this.scene)?void 0:e.removeEntityToCache(this),null==(t=this.scene)?void 0:t.native.removeEntity(this.native),this.native=void 0,this.scene=void 0,this._transform=void 0}get children(){const e=[];for(let a=0;a<this._transform.children.size();++a){var t;const n=this._transform.children.get(a),i=null==(t=this.scene)?void 0:t.entityFromNative(n.entity);if(i)e.push(i);else throw new Error("Entity has invalid child!")}return e}getComponent(e){let t;if("string"==typeof e){const a=this.native.getComponents(Me.nativeClasses[0]);for(let n=0;n<a.size();++n){const i=a.get(n);if(i.getScript().className===e){this._components.has(i.handle)?t=this._components.get(i.handle):(t=Me.fromNative(this,i),this._components.set(i.handle,t));break}}}else if(e.nativeClasses)for(const a of e.nativeClasses){const n=this.native.getComponent(a);if(n){this._components.has(n.handle)?t=this._components.get(n.handle):(t=e.fromNative(this,n),this._components.set(n.handle,t));break}}return t}getComponents(e){const t=[];if(e.nativeClasses)for(const a of e.nativeClasses){const n=this.native.getComponents(a);for(let a=0;a<n.size();++a){const i=n.get(a);let r;this._components.has(i.handle)?r=this._components.get(i.handle):(r=e.fromNative(this,i),this._components.set(i.handle,r)),t.push(r)}}return t}hasComponent(e){let t=!1;if(e.nativeClasses)for(const a of e.nativeClasses)if(t=!!this.native.getComponent(a),t)break;return t}findByComponent(e){let t;if(this.hasComponent(e))t=this;else for(const a of this.children)if(t=a.findByComponent(e),t)break;return t}findAllByComponent(e){const t=[];this.hasComponent(e)&&t.push(this);for(const a of this.children)t.push(...a.findAllByComponent(e));return t}}class Ee{constructor(e){if(this.entities=new Map,this._physicsSystem=void 0,e&&e instanceof t.Scene){this.native=e;const t=this.native.entities,a=t.empty()?void 0:this.findRoot(t);this.root=a?this.entityFromNative(a):new Ae("Root",{scene:this})}else this.native=new t.Scene,this.name="string"==typeof e?e:"Untitled",this.root=new Ae("Root",{scene:this});t.AmazingManager.addScene(this.native)}findRoot(e){let t=e.front().getComponent("Transform");for(;t.parent;)t=t.parent;return t.entity}get children(){const e=[];for(let t=0;t<this.native.entities.size();++t){const a=this.native.entities.get(t),n=a.getComponent("Transform");if(!n)throw new Error("Scene has invalid child entity!");else if(!n.parent){const t=this.entityFromNative(a);if(t)e.push(t);else throw new Error("Scene has invalid child entity!")}}return e}get name(){return this.native.name}set name(e){this.native.name=e}get visible(){return this.native.visible}set visible(e){this.native.visible=e}addSystem(e){this.native.addSystem(e)}addEntityToCache(e){e.native.handle&&this.entities.set(e.native.handle,e)}removeEntityToCache(e){e.native.handle&&this.entities.delete(e.native.handle)}entityFromNative(e){return e?e.handle&&this.entities.has(e.handle)?this.entities.get(e.handle):Ae.fromNative(this,e):void 0}destroy(){this.entities.clear(),this.native.visible=!1,t.AmazingManager.removeScene(this.native)}rayCast(e,t){const a=[],n=this.physicsSystem.rayTest(e,t);for(let r=0;r<n.size();++r){const e=n.get(r),t=this.entityFromNative(e.entity);t&&a.push(t)}return a}findByName(e){let t;for(let a=0;a<this.native.entities.size();++a){const n=this.entityFromNative(this.native.entities.get(a));if(n&&n.name===e){t=n;break}}return t}findByTag(e){let t;for(let a=0;a<this.native.entities.size();++a){const n=this.entityFromNative(this.native.entities.get(a));if(n&&n.hasTag(e)){t=n;break}}return t}findByComponent(e){let t;for(let a=0;a<this.native.entities.size();++a){const n=this.entityFromNative(this.native.entities.get(a));if(n&&n.hasComponent(e)){t=n;break}}return t}findAllByName(e){const t=[];for(let a=0;a<this.native.entities.size();++a){const n=this.entityFromNative(this.native.entities.get(a));n&&n.name===e&&t.push(n)}return t}findAllByTag(e){const t=[];for(let a=0;a<this.native.entities.size();++a){const n=this.entityFromNative(this.native.entities.get(a));n&&n.hasTag(e)&&t.push(n)}return t}findAllByComponent(e){const t=[];for(let a=0;a<this.native.entities.size();++a){const n=this.entityFromNative(this.native.entities.get(a));n&&n.hasComponent(e)&&t.push(n)}return t}get physicsSystem(){return void 0===this._physicsSystem&&(this._physicsSystem=this.native.getSystem("Physics3DSystem")),this._physicsSystem}}var ke;(function(e){e[e.TouchStart=0]="TouchStart",e[e.TouchMove=1]="TouchMove",e[e.TouchStationary=2]="TouchStationary",e[e.TouchEnd=3]="TouchEnd",e[e.TouchCancel=4]="TouchCancel"})(ke||(ke={}));class Le{constructor(e,t,a,n,i,r,o,s){this.identifier=-1,this.type=ke.TouchStart,this.x=0,this.y=0,this.force=0,this.size=0,this.time=0,this.count=0,this.valid=!1,e!==void 0&&(this.identifier=e,this.valid=!0),t!==void 0&&(this.type=t),a!==void 0&&(this.x=a),n!==void 0&&(this.y=n),i!==void 0&&(this.force=i),r!==void 0&&(this.size=r),o!==void 0&&(this.time=o),s!==void 0&&(this.count=s)}static fromNative(e){const t=new Le(e.pointerId,Le.convertTouchType(e.type),e.x,e.y,e.force,e.size,e.time,e.count);return t}static convertTouchType(e){return e===t.TouchType.TOUCH_BEGAN?ke.TouchStart:e===t.TouchType.TOUCH_MOVED?ke.TouchMove:e===t.TouchType.TOUCH_STATIONARY?ke.TouchStationary:e===t.TouchType.TOUCH_ENDED?ke.TouchEnd:e===t.TouchType.TOUCH_CANCELED?ke.TouchCancel:ke.TouchEnd}}class Ne extends e{constructor(e,t){super(),this._width=e,this._height=t}start(){}destroy(){}onEvent(e){if(e.type===t.EventType.TOUCH){const t=e.args.get(0),a=this.convertTouchEvent(t);switch(a.type){case ke.TouchStart:this.fire("touchstart",a);break;case ke.TouchMove:this.fire("touchmove",a);break;case ke.TouchEnd:this.fire("touchend",a);break;case ke.TouchCancel:this.fire("touchcancel",a);}}}convertTouchEvent(e){var t=Math.round;const a=t(e.x*this._width),n=this._height-t(e.y*this._height),i=Le.fromNative(e);return i.x=a,i.y=n,i}}class be{static toPascalCase(e){return e?`${e}`.replace(new RegExp(/[-_]+/,"g")," ").replace(new RegExp(/[^\w\s]/,"g"),"").replace(new RegExp(/\s+(.)(\w*)/,"g"),(e,t,a)=>`${t.toUpperCase()+a.toLowerCase()}`).replace(new RegExp(/\w/),e=>e.toUpperCase()):e}static getFilename(e){return e.substring(e.lastIndexOf("/")+1)}}class De{static createQuadMesh(){const e=new t.Mesh,a=new t.VertexAttribDesc;a.semantic=t.VertexAttribType.POSITION;const n=new t.VertexAttribDesc;n.semantic=t.VertexAttribType.TEXCOORD0;const i=new t.Vector;i.insert(0,a),i.insert(1,n),e.vertexAttribs=i;const r=-1,o=1,s=1,d=[o,s,0,1,1,o,r,0,1,0,-1,r,0,0,0,-1,s,0,0,1],l=new t.FloatVector;for(let e=0;e<d.length;++e)l.insert(e,d[e]);e.vertices=l;const c=new t.SubMesh;c.primitive=t.Primitive.TRIANGLES;const p=[0,1,2,2,3,0],u=new t.UInt16Vector;for(let e=0;e<p.length;++e)u.insert(e,p[e]);return c.indices16=u,c.mesh=e,e.addSubMesh(c),e}}class Be{static createShaderPass(e,a){const n=new t.Pass;n.shaders=e;const i=new t.Map;return i.insert("inPosition",t.VertexAttribType.POSITION),i.insert("inTexCoord",t.VertexAttribType.TEXCOORD0),n.semantics=i,n.renderState=a,n}static createScreenMaterial(e){const a=new t.RenderState;a.viewport=new t.ViewportState,a.viewport.rect=new t.Rect(0,0,1,1),a.viewport.minDepth=0,a.viewport.maxDepth=1;const n=this.createShaderPass(e,a);return this.createMaterial(n)}static createMaterial(e){const a=new t.XShader;a.passes.pushBack(e);const n=new t.Material;n.xshader=a;const i=new t.PropertySheet;return n.properties=i,n}static createRenderTexture(){const e=new t.RenderTexture;return e.depth=1,e.width=640,e.height=360,e.filterMag=t.FilterMode.LINEAR,e.filterMin=t.FilterMode.LINEAR,e.filterMipmap=t.FilterMipmapMode.NONE,e.attachment=t.RenderTextureAttachment.NONE,e}static createRenderTexturePlus(e,a,n,i){const r=new t.RenderTexture;return r.builtinType=t.BuiltInTextureType.NORAML,r.internalFormat=t.InternalFormat.RGBA8,r.dataType=t.DataType.U8norm,r.depth=1,r.attachment=t.RenderTextureAttachment.DEPTH24,r.filterMag=i,r.filterMin=i,r.filterMipmap=t.FilterMipmapMode.NONE,r.width=e,r.height=a,r.colorFormat=n,r}static createTexture2D(){const e=new t.Texture2D;return e.filterMin=t.FilterMode.LINEAR,e.filterMag=t.FilterMode.LINEAR,e}static createShaders(e){const a=new t.Map;for(const n in e){const i=new t.Shader;i.type=t.ShaderType.VERTEX,i.source=e[n].vs;const r=new t.Shader;r.type=t.ShaderType.FRAGMENT,r.source=e[n].fs;const o=new t.Vector;o.insert(0,i),o.insert(1,r),a.insert(n,o)}return a}static createEmptyMaterial(){const e=new t.Material,a=new t.XShader;e.xshader=a;const n=new t.PropertySheet;return e.properties=n,e}static addPassToMaterial(e,a,n,i=!1){const r=new t.Pass,o=new t.Map;for(const r in a){const e=new t.Shader;e.type=t.ShaderType.VERTEX,e.source=a[r].vs;const n=new t.Shader;n.type=t.ShaderType.FRAGMENT,n.source=a[r].fs;const i=new t.Vector;i.pushBack(e),i.pushBack(n),o.insert(r,i)}r.shaders=o;const s=new t.Map;s.insert("inPosition",t.VertexAttribType.POSITION),s.insert("inTexCoord",t.VertexAttribType.TEXCOORD0),r.semantics=s;const d=new t.DepthStencilState;d.depthTestEnable=!1;const l=new t.RenderState;if(l.depthstencil=d,n){d.stencilTestEnable=!0;const e=new t.StencilOpState;e.compareOp=t.CompareOp.EQUAL,e.reference=42,e.writeMask=0,d.stencilFront=e,d.stencilBack=e}if(i){const e=new t.Vector,a=new t.ColorBlendAttachmentState;a.blendEnable=i,a.srcColorBlendFactor=t.BlendFactor.SRC_ALPHA,a.dstColorBlendFactor=t.BlendFactor.ONE_MINUS_SRC_ALPHA,a.srcAlphaBlendFactor=t.BlendFactor.SRC_ALPHA,a.dstAlphaBlendFactor=t.BlendFactor.ONE_MINUS_SRC_ALPHA,a.ColorBlendOp=t.BlendOp.ADD,a.AlphaBlendOp=t.BlendOp.ADD,e.pushBack(a),l.colorBlend=new t.ColorBlendState,l.colorBlend.attachments=e}return r.renderState=l,e.xshader.passes.pushBack(r),r}}class we{constructor(){this._screenMesh=De.createQuadMesh(),this._cmdBuffer=new t.CommandBuffer,this._cmdBufferDirty=!1}onPreUpdate(){this._cmdBuffer.clearAll()}onPostUpdate(){var e;const t=null==(e=Ua.engine)?void 0:e.scene.native;t&&this._cmdBufferDirty&&(t.commitCommandBuffer(this._cmdBuffer),this._cmdBufferDirty=!1)}get screenMesh(){return this._screenMesh}cmdBufferSetRenderTexture(e){this._cmdBuffer.setRenderTexture(e),this._cmdBufferDirty=!0}cmdBufferClearRenderTexture(e,t,a,n){this._cmdBuffer.clearRenderTexture(e,t,a,n),this._cmdBufferDirty=!0}cmdBufferDrawMesh(e,t,a,n,i,r){this._cmdBuffer.drawMesh(e,t,a,n,i,r),this._cmdBufferDirty=!0}cmdBufferBlit(e,t){this._cmdBuffer.blit(e,t),this._cmdBufferDirty=!0}}class Oe{static checkSDKVersion(e){const a=t.VERSION.split(".").map(e=>parseInt(e)),n=e.split(".").map(e=>parseInt(e));for(let t=0;t<a.length;++t){if(n[t]<a[t])return!0;if(n[t]>a[t])return!1}return!0}}class ze{constructor(e){var a,n;const i=e.properties;this._flip=i.flip,this._inputTexture=i.inputTexture,this._renderTexture=null==(a=Ua.engine)?void 0:a.customAssets.getNativeObject(e.uuid),this._renderTexture.depth=1,this._renderTexture.filterMag=t.FilterMode.LINEAR,this._renderTexture.filterMin=t.FilterMode.LINEAR,this._renderTexture.filterMipmap=t.FilterMipmapMode.NONE,this._renderTexture.attachment=t.RenderTextureAttachment.NONE,this._renderTexture.width=t.AmazingManager.getSingleton("BuiltinObject").getInputTextureWidth(),this._renderTexture.height=t.AmazingManager.getSingleton("BuiltinObject").getInputTextureHeight();const r=Be.createShaders({gles2:{vs:"\n    precision highp float;\n\n    attribute vec3 inPosition;\n    attribute vec2 inTexCoord;\n\n    varying vec2 v_TexCoord;\n\n    uniform mat4 u_Model;\n    uniform float u_FlipVertical;\n\n    void main() {\n      vec2 flipCoord = vec2(inTexCoord.x, 1. - inTexCoord.y);\n      v_TexCoord = mix(inTexCoord, flipCoord, u_FlipVertical);\n      gl_Position = u_Model * vec4(inPosition, 1.0);\n    }\n    ",fs:`
    precision highp float;

    varying vec2 v_TexCoord;

    uniform sampler2D u_CameraTex;

    void main() {
      gl_FragColor = texture2D(u_CameraTex, v_TexCoord);
    }
    `},metal:{vs:`
    #include <metal_stdlib>
    #include <simd/simd.h>
    
    using namespace metal;
    
    struct buffer_t
    {
        float u_FlipVertical;
        float4x4 u_Model;
    };
    
    struct main0_out
    {
        float2 v_TexCoord;
        float4 gl_Position [[position]];
    };
    
    struct main0_in
    {
        float3 inPosition [[attribute(0)]];
        float2 inTexCoord [[attribute(1)]];
    };
    
    vertex main0_out main0(main0_in in [[stage_in]], constant buffer_t& buffer)
    {
        main0_out out = {};
        float2 flipCoord = float2(in.inTexCoord.x, 1.0 - in.inTexCoord.y);
        out.v_TexCoord = mix(in.inTexCoord, flipCoord, float2(buffer.u_FlipVertical));
        out.gl_Position = buffer.u_Model * float4(in.inPosition, 1.0);
        out.gl_Position.z = (out.gl_Position.z + out.gl_Position.w) * 0.5;       // Adjust clip-space for Metal
        return out;
    }
    `,fs:`
    #include <metal_stdlib>
    #include <simd/simd.h>

    using namespace metal;

    struct main0_out
    {
        float4 gl_FragColor [[color(0)]];
    };

    struct main0_in
    {
        float2 v_TexCoord;
    };

    fragment main0_out main0(main0_in in [[stage_in]], texture2d<float> u_CameraTex [[texture(0)]], sampler u_CameraTexSmplr [[sampler(0)]])
    {
        main0_out out = {};
        out.gl_FragColor = u_CameraTex.sample(u_CameraTexSmplr, in.v_TexCoord);
        return out;
    }
    `}});this._screenMaterial=Be.createScreenMaterial(r);const o=null==(n=Ua.engine)?void 0:n.assets.loadSync(this._inputTexture);this._screenMaterial.setTex("u_CameraTex",null==o?void 0:o.resource);const s=!0===this._flip?1:0;this._screenMaterial.setFloat("u_FlipVertical",s)}onStart(){}onUpdate(){const e=Ua.engine.customAssets.cmdBufferHelper;e.cmdBufferSetRenderTexture(this._renderTexture),e.cmdBufferDrawMesh(e.screenMesh,new C,this._screenMaterial,0,0,new t.MaterialPropertyBlock)}onLateUpdate(){}onDestroy(){}}var Ve;(function(e){e[e.Human=0]="Human",e[e.Pet=1]="Pet"})(Ve||(Ve={}));const He=new Map([[exports.FaceType.Unknown,Ve.Human],[exports.FaceType.Human,Ve.Human],[exports.FaceType.Dog,Ve.Pet],[exports.FaceType.Cat,Ve.Pet]]);class Ue{constructor(){this.vertexes=new t.Vec3Vector,this.landmarks=new t.Vec3Vector,this.normals=new t.Vec3Vector,this.tangents=new t.Vec3Vector,this.mvp=new C,this.modelMatrix=new C,this.scale=0}}class Ge{constructor(){this.type=exports.FaceType.Unknown,this.score=0,this.id=0,this.yaw=0,this.pitch=0,this.roll=0,this.transform=new C,this.rect=new t.Rect,this.expression=exports.FaceExpression.Unknown,this.isValidFace=!1,this.action=exports.FaceAction.None,this.faceMesh=new Ue,this.landmarks106=new t.Vec2Vector,this.landmarks240EyeLeft=new t.Vec2Vector,this.landmarks240EyeRight=new t.Vec2Vector,this.landmarks240EyebrowLeft=new t.Vec2Vector,this.landmarks240EyebrowRight=new t.Vec2Vector,this.landmarks240Lip=new t.Vec2Vector,this.landmarks280LeftIris=new t.Vec2Vector,this.landmarks280RightIris=new t.Vec2Vector,this.landmarks3d=new t.Vec3Vector,this.landmarksPetV2=new t.Vec2Vector}isValid(){return this.isValidFace}hasAction(){return this.action!==exports.FaceAction.None}}const We=5;class qe{static getFaceIndex(e,t){return(t===exports.FaceType.Human?0:We)+e}}class Ye{constructor(e){this._mgr=e,this.lastFaceIdSet=new Set}facePartHelper(e,t,a,n){for(let r=e;r<t;r++)n.pushBack(a.get(r));return n}update(e){const t=new Set;this.onUpdate(e,t);for(const a of this.lastFaceIdSet.values())t.has(a)||this._mgr.setFaceState(!1,a);this.lastFaceIdSet.clear(),t.forEach(e=>this.lastFaceIdSet.add(e))}}class je extends Ye{constructor(e){super(e)}getLandmark(e,t,a){return a===exports.FaceLandmarkType.Face106?this.get106landmark(e,t):a===exports.FaceLandmarkType.Face240?this.get240landmark(e,t):a===exports.FaceLandmarkType.Face280?this.get280landmark(e,t):a===exports.FaceLandmarkType.Face3d?this.get3dlandmark(e,t):(console.error(`Head doesn't support ${a} yet`),null)}get106landmark(e,a){switch(e){case exports.FacePart.Whole:return this._mgr.faces[a].landmarks106;case exports.FacePart.LeftEye:let n=new t.Vec2Vector;return n=this.facePartHelper(52,58,this._mgr.faces[a].landmarks106,n),n=this.facePartHelper(72,74,this._mgr.faces[a].landmarks106,n),n=this.facePartHelper(104,105,this._mgr.faces[a].landmarks106,n),n;case exports.FacePart.RightEye:let i=new t.Vec2Vector;return i=this.facePartHelper(58,64,this._mgr.faces[a].landmarks106,i),i=this.facePartHelper(75,78,this._mgr.faces[a].landmarks106,i),i=this.facePartHelper(105,106,this._mgr.faces[a].landmarks106,i),i;case exports.FacePart.Nose:let r=new t.Vec2Vector;return r=this.facePartHelper(43,52,this._mgr.faces[a].landmarks106,r),r=this.facePartHelper(80,84,this._mgr.faces[a].landmarks106,r),r;case exports.FacePart.Mouth:let o=new t.Vec2Vector;return o=this.facePartHelper(84,104,this._mgr.faces[a].landmarks106,o),o;case exports.FacePart.LeftEyeBrow:let s=new t.Vec2Vector;return s=this.facePartHelper(33,38,this._mgr.faces[a].landmarks106,s),s=this.facePartHelper(64,68,this._mgr.faces[a].landmarks106,s),s;case exports.FacePart.RightEyeBrow:let d=new t.Vec2Vector;return d=this.facePartHelper(38,43,this._mgr.faces[a].landmarks106,d),d=this.facePartHelper(68,72,this._mgr.faces[a].landmarks106,d),d;default:return console.error(`Head 106 doesn't support ${e} yet`),null;}}get240landmark(e,t){switch(e){case exports.FacePart.Whole:let a=this.facePartHelper(0,this._mgr.faces[t].landmarks240EyeLeft.size(),this._mgr.faces[t].landmarks240EyeLeft,this._mgr.faces[t].landmarks106);return a=this.facePartHelper(0,this._mgr.faces[t].landmarks240EyeRight.size(),this._mgr.faces[t].landmarks240EyeRight,a),a=this.facePartHelper(0,this._mgr.faces[t].landmarks240EyebrowLeft.size(),this._mgr.faces[t].landmarks240EyebrowLeft,a),a=this.facePartHelper(0,this._mgr.faces[t].landmarks240EyebrowRight.size(),this._mgr.faces[t].landmarks240EyebrowRight,a),a=this.facePartHelper(0,this._mgr.faces[t].landmarks240Lip.size(),this._mgr.faces[t].landmarks240Lip,a),a;case exports.FacePart.LeftEye:const n=this._mgr.getLandmarks(exports.FacePart.LeftEye,t,exports.FaceLandmarkType.Face106),i=this.facePartHelper(0,this._mgr.faces[t].landmarks240EyeLeft.size(),this._mgr.faces[t].landmarks240EyeLeft,n);return i;case exports.FacePart.RightEye:const r=this._mgr.getLandmarks(exports.FacePart.RightEye,t,exports.FaceLandmarkType.Face106),o=this.facePartHelper(0,this._mgr.faces[t].landmarks240EyeRight.size(),this._mgr.faces[t].landmarks240EyeRight,r);return o;case exports.FacePart.Nose:const s=this._mgr.getLandmarks(exports.FacePart.Nose,t,exports.FaceLandmarkType.Face106);return s;case exports.FacePart.Mouth:const d=this._mgr.getLandmarks(exports.FacePart.Mouth,t,exports.FaceLandmarkType.Face106),l=this.facePartHelper(0,this._mgr.faces[t].landmarks240Lip.size(),this._mgr.faces[t].landmarks240Lip,d);return l;case exports.FacePart.LeftEyeBrow:const c=this._mgr.getLandmarks(exports.FacePart.LeftEyeBrow,t,exports.FaceLandmarkType.Face106),p=this.facePartHelper(0,this._mgr.faces[t].landmarks240EyebrowLeft.size(),this._mgr.faces[t].landmarks240EyebrowLeft,c);return p;case exports.FacePart.RightEyeBrow:const u=this._mgr.getLandmarks(exports.FacePart.RightEyeBrow,t,exports.FaceLandmarkType.Face106),m=this.facePartHelper(0,this._mgr.faces[t].landmarks240EyebrowRight.size(),this._mgr.faces[t].landmarks240EyebrowRight,u);return m;default:return console.error(`Head 240 doesn't support ${e} yet`),null;}}get280landmark(e,t){switch(e){case exports.FacePart.Whole:const a=this._mgr.getLandmarks(exports.FacePart.Whole,t,exports.FaceLandmarkType.Face240);let n=this.facePartHelper(0,this._mgr.faces[t].landmarks280LeftIris.size(),this._mgr.faces[t].landmarks280LeftIris,a);return n=this.facePartHelper(0,this._mgr.faces[t].landmarks280RightIris.size(),this._mgr.faces[t].landmarks280RightIris,n),n;case exports.FacePart.LeftEye:const i=this._mgr.getLandmarks(exports.FacePart.LeftEye,t,exports.FaceLandmarkType.Face240),r=this.facePartHelper(0,this._mgr.faces[t].landmarks280LeftIris.size(),this._mgr.faces[t].landmarks280LeftIris,i);return r;case exports.FacePart.RightEye:const o=this._mgr.getLandmarks(exports.FacePart.RightEye,t,exports.FaceLandmarkType.Face240),s=this.facePartHelper(0,this._mgr.faces[t].landmarks280RightIris.size(),this._mgr.faces[t].landmarks280RightIris,o);return s;case exports.FacePart.Nose:const d=this._mgr.getLandmarks(exports.FacePart.Nose,t,exports.FaceLandmarkType.Face240);return d;case exports.FacePart.Mouth:const l=this._mgr.getLandmarks(exports.FacePart.Mouth,t,exports.FaceLandmarkType.Face240);return l;case exports.FacePart.LeftEyeBrow:const c=this._mgr.getLandmarks(exports.FacePart.LeftEyeBrow,t,exports.FaceLandmarkType.Face240);return c;case exports.FacePart.RightEyeBrow:const p=this._mgr.getLandmarks(exports.FacePart.RightEyeBrow,t,exports.FaceLandmarkType.Face240);return p;default:return console.error(`Head 280 doesn't support ${e} yet`),null;}}get3dlandmark(e,t){return e===exports.FacePart.Whole?this._mgr.faces[t].landmarks3d:(console.error(`Head 3d doesn't support ${e} yet`),null)}onUpdate(e,t){if(e.has(exports.FaceType.Human)){var a;const e=null==(a=Ua.engine)?void 0:a.algoritms.nativeResult,n=e.getFaceCount();if(0<n)for(let a=0;a<n;a++){const n=e.getFaceBaseInfo(a),i=e.getFaceAttributeInfo(a),r=e.getFaceExtraInfo(a),o=e.getFaceMeshInfo(a);if(null!=n){const e=new Ge;this._mgr.addFaceData(e);const a=qe.getFaceIndex(n.ID,exports.FaceType.Human);this._mgr.setFaceState(!0,a),t.add(a),e.isValidFace=!0,e.type=exports.FaceType.Human,e.score=n.score,e.id=a,e.yaw=n.yaw,e.pitch=n.pitch,e.roll=n.roll,e.rect=n.rect,e.action=n.action,e.landmarks106=n.points_array,null!=r&&(e.landmarks240EyeLeft=r.eye_left,e.landmarks240EyeRight=r.eye_right,e.landmarks240EyebrowLeft=r.eyebrow_left,e.landmarks240EyebrowRight=r.eyebrow_right,e.landmarks240Lip=r.lips,e.landmarks280LeftIris=r.left_iris,e.landmarks280RightIris=r.right_iris),null!=i&&(e.expression=i.exp_type),null!=o&&(e.landmarks3d=o.landmarks,e.faceMesh.vertexes=o.vertexes,e.faceMesh.normals=o.normals,e.faceMesh.tangents=o.tangents,e.faceMesh.scale=o.scale,e.faceMesh.mvp=o.mvp,e.faceMesh.modelMatrix=o.modelMatrix)}else console.error("Invalid face data:"+a)}}}}class Ke extends Ye{constructor(e){super(e)}getLandmark(e,t,a){if(a&&a!==exports.FaceLandmarkType.PetV2)console.error("Cannot get landmark for non-pet type.");else{const a=this._mgr.faces[t];if(a.type===exports.FaceType.Dog)return this.getLandmarkDog(e,a);if(a.type===exports.FaceType.Cat)return this.getLandmarkCat(e,a);console.error("Cannot get landmark for non-pet type.")}}getLandmarkDog(e,a){switch(e){case exports.FacePart.Whole:return a.landmarksPetV2;case exports.FacePart.LeftEye:let n=new t.Vec2Vector;return n=this.facePartHelper(58,66,a.landmarksPetV2,n),n=this.facePartHelper(74,75,a.landmarksPetV2,n),n;case exports.FacePart.RightEye:let i=new t.Vec2Vector;return i=this.facePartHelper(66,74,a.landmarksPetV2,i),i=this.facePartHelper(75,76,a.landmarksPetV2,i),i;case exports.FacePart.Nose:let r=new t.Vec2Vector;return r=this.facePartHelper(26,42,a.landmarksPetV2,r),r;case exports.FacePart.Mouth:let o=new t.Vec2Vector;return o=this.facePartHelper(42,58,a.landmarksPetV2,o),o;case exports.FacePart.LeftEar:let s=new t.Vec2Vector;return s=this.facePartHelper(0,1,a.landmarksPetV2,s),s=this.facePartHelper(23,26,a.landmarksPetV2,s),s=this.facePartHelper(76,83,a.landmarksPetV2,s),s;case exports.FacePart.RightEar:let d=new t.Vec2Vector;return d=this.facePartHelper(16,20,a.landmarksPetV2,d),d=this.facePartHelper(83,90,a.landmarksPetV2,d),d;default:return console.error(`Dog face doesn't support ${e} yet`),null;}}getLandmarkCat(e,a){switch(e){case exports.FacePart.Whole:return a.landmarksPetV2;case exports.FacePart.LeftEye:let n=new t.Vec2Vector;return n=this.facePartHelper(64,72,a.landmarksPetV2,n),n=this.facePartHelper(80,81,a.landmarksPetV2,n),n;case exports.FacePart.RightEye:let i=new t.Vec2Vector;return i=this.facePartHelper(72,80,a.landmarksPetV2,i),i=this.facePartHelper(81,82,a.landmarksPetV2,i),i;case exports.FacePart.Nose:let r=new t.Vec2Vector;return r=this.facePartHelper(40,48,a.landmarksPetV2,r),r;case exports.FacePart.Mouth:let o=new t.Vec2Vector;return o=this.facePartHelper(48,64,a.landmarksPetV2,o),o;case exports.FacePart.LeftEar:let s=new t.Vec2Vector;return s=this.facePartHelper(0,1,a.landmarksPetV2,s),s=this.facePartHelper(23,33,a.landmarksPetV2,s),s;case exports.FacePart.RightEar:let d=new t.Vec2Vector;return d=this.facePartHelper(16,20,a.landmarksPetV2,d),d=this.facePartHelper(33,40,a.landmarksPetV2,d),d;default:return console.error(`Cat face doesn't support ${e} yet`),null;}}getFaceType(e){return e===t.FacePetType.CAT?exports.FaceType.Cat:e===t.FacePetType.DOG?exports.FaceType.Dog:exports.FaceType.Human}onUpdate(e,t){if(e.has(exports.FaceType.Dog)||e.has(exports.FaceType.Cat)){var a;const n=null==(a=Ua.engine)?void 0:a.algoritms.nativeResult,i=n.getFacePetInfoCount();if(0<i)for(let a=0;a<i;a++){const i=n.getFacePetInfo(a);if(null!=i){const a=this.getFaceType(i.face_pet_type);if(e.has(a)){const e=new Ge;this._mgr.addFaceData(e);const n=qe.getFaceIndex(i.Id,a);this._mgr.setFaceState(!0,n),t.add(n),e.isValidFace=!0,e.type=a,e.score=i.score,e.id=n,e.yaw=i.yaw,e.pitch=i.pitch,e.roll=i.roll,e.rect=i.rect,e.action=i.action,e.landmarksPetV2=i.points_array}}else console.error("Invalid face data:"+a)}}}}class Xe extends e{constructor(){super(),this.faces=[],this._faceProviders=new Map,this._faceProviders.set(Ve.Human,new je(this)),this._faceProviders.set(Ve.Pet,new Ke(this)),this.hasFaceMap=new Map,this._filter=new Set([exports.FaceType.Human])}static getInstance(){return null==this._instance&&(this._instance=new Xe),this._instance}static setFilter(e){this.getInstance().setFilter(e)}static getLandmark(e,t,a){return this.getInstance().getLandmarks(e,t,a)}setFilter(e){this._filter=new Set(e)}getLandmarks(e,t,a){const n=this.faces[t],i=He.get(n.type),r=this._faceProviders.get(i);return r?r.getLandmark(e,t,a):void console.error("Cannot get landmark data for face: "+t)}onUpdate(){this.resetFaceData();for(const e of this._faceProviders.values())e.update(this._filter)}init(){}resetFaceData(){this.faces.length=0}addFaceData(e){this.faces.push(e)}static get faces(){return this.getInstance().faces}static on(e,t,a){return this.getInstance().on(e,t,a)}static off(e,t,a){return this.getInstance().off(e,t,a)}setFaceState(e,t){this.hasFaceMap.has(t)||this.hasFaceMap.set(t,!1),this.hasFaceMap.get(t)!==e&&(!0===e?this.fire(exports.FaceEvent.Detected,t):this.fire(exports.FaceEvent.Lost,t),this.hasFaceMap.set(t,e))}}class Qe{constructor(e){var a,n,i;const r=e.properties;this._initialized=!1,this._faceIndex=r.faceIndex,this._textureResScale=r.textureResScale,this._meshPath=r.meshPath,this._flipUv=r.flipUv,this._renderTexture=null==(a=Ua.engine)?void 0:a.customAssets.getNativeObject(e.uuid),this._renderTexture.depth=1,this._renderTexture.width=640,this._renderTexture.height=360,this._renderTexture.filterMag=t.FilterMode.LINEAR,this._renderTexture.filterMin=t.FilterMode.LINEAR,this._renderTexture.filterMipmap=t.FilterMipmapMode.NONE,this._renderTexture.attachment=t.RenderTextureAttachment.NONE;const o=Be.createShaders({gles2:{vs:"precision highp float;\n    attribute vec3 attPosition;\n    attribute vec2 attTexcoord0;\n    uniform mat4 u_Model;\n    uniform mat4 u_MVP;\n    uniform float u_flipUv;\n    varying vec2 g_vary_uv0;\n    varying vec4 v_sampling_pos;\n    void main ()\n    {\n      vec4 homogeneous_pos = vec4(attPosition, 1.0);\n      g_vary_uv0 = attTexcoord0;\n      v_sampling_pos = u_MVP * homogeneous_pos;\n      if (u_flipUv > 0.5) {\n        g_vary_uv0.y = 1. - g_vary_uv0.y;\n      }\n      vec2 uv_pos = g_vary_uv0.xy * 2.0 - vec2(1.0);\n      gl_Position = vec4(uv_pos, 0.0, 1.0);\n    }\n    ",fs:`precision highp float;
    uniform sampler2D u_AlbedoTexture;
    varying vec4 v_sampling_pos;
    void main ()
    {
      vec2 sampling_uv = (v_sampling_pos.xy / v_sampling_pos.w) * 0.5 + 0.5;
      vec4 textureColor = texture2D( u_AlbedoTexture, sampling_uv);
      gl_FragColor = textureColor;
    }
    `},metal:{vs:`
    #include <metal_stdlib>
    #include <simd/simd.h>

    using namespace metal;

    struct buffer_t
    {
        float4x4 u_MVP;
        float u_flipUv;
    };

    struct main0_out
    {
        float2 g_vary_uv0;
        float4 v_sampling_pos;
        float4 gl_Position [[position]];
    };

    struct main0_in
    {
        float3 attPosition [[attribute(0)]];
        float2 attTexcoord0 [[attribute(1)]];
    };

    vertex main0_out main0(main0_in in [[stage_in]], constant buffer_t& buffer)
    {
        main0_out out = {};
        float4 homogeneous_pos = float4(in.attPosition, 1.0);
        out.g_vary_uv0 = in.attTexcoord0;
        out.v_sampling_pos = buffer.u_MVP * homogeneous_pos;
        if (buffer.u_flipUv > 0.5)
        {
            out.g_vary_uv0.y = 1.0 - out.g_vary_uv0.y;
        }
        float2 uv_pos = (out.g_vary_uv0 * 2.0) - float2(1.0);
        out.gl_Position = float4(uv_pos, 0.0, 1.0);
        out.gl_Position.z = (out.gl_Position.z + out.gl_Position.w) * 0.5;       // Adjust clip-space for Metal
        return out;
    }
    `,fs:`
    #include <metal_stdlib>
    #include <simd/simd.h>

    using namespace metal;

    struct main0_out
    {
        float4 gl_FragColor [[color(0)]];
    };

    struct main0_in
    {
        float4 v_sampling_pos;
    };

    fragment main0_out main0(main0_in in [[stage_in]], texture2d<float> u_AlbedoTexture [[texture(0)]], sampler u_AlbedoTextureSmplr [[sampler(0)]])
    {
        main0_out out = {};
        float2 sampling_uv = ((in.v_sampling_pos.xy / float2(in.v_sampling_pos.w)) * 0.5) + float2(0.5);
        float4 textureColor = u_AlbedoTexture.sample(u_AlbedoTextureSmplr, sampling_uv);
        out.gl_FragColor = textureColor;
        return out;
    }
    `}});this._faceMaterial=this.createFaceTexMaterial(o);const s=null==(n=Ua.engine)?void 0:n.assets.loadSync("share://input.texture");this._faceMaterial.setTex("u_AlbedoTexture",null==s?void 0:s.resource),this._faceMaterial.setFloat("u_flipUv",!0===this._flipUv?1:0),this._renderTexture.width=t.AmazingManager.getSingleton("BuiltinObject").getOutputTextureWidth()*this._textureResScale,this._renderTexture.height=t.AmazingManager.getSingleton("BuiltinObject").getOutputTextureHeight()*this._textureResScale,this._faceMesh=null==(i=Ua.engine.assets.loadSync(this._meshPath))?void 0:i.resource}onStart(){}onLateUpdate(){}onDestroy(){}onUpdate(){const e=Ua.engine.customAssets.cmdBufferHelper;if(this._initialized||(e.cmdBufferSetRenderTexture(this._renderTexture),e.cmdBufferClearRenderTexture(!0,!0,new t.Color(0,0,0,0),0),this._initialized=!0),null!=this._faceMesh&&null!=this._faceMaterial){const a=Xe.faces,n=a.length;if(n<=this._faceIndex)return;const i=a[this._faceIndex].faceMesh;if(null===i)return;const r=i.vertexes,o=i.normals;null!=r&&null!=o&&0<r.size()&&0<o.size()&&(this._faceMaterial.setMat4("u_MVP",i.mvp),this._faceMesh.setVertexArray(r),this._faceMesh.setNormalArray(o));const s=new C;s.setIdentity(),e.cmdBufferSetRenderTexture(this._renderTexture),e.cmdBufferDrawMesh(this._faceMesh,s,this._faceMaterial,0,0,new t.MaterialPropertyBlock)}else null==this._faceMesh&&console.error("face texture asset: mesh not found!"),null==this._faceMaterial&&console.error("face texture asset: material not found!")}createFaceTexMaterial(e){const a=new t.Pass;a.shaders=e,a.clearColor=new t.Color(0,0,0,1),a.clearType=t.CameraClearType.COLOR_DEPTH;const n=new t.Map;n.insert("attColor",t.VertexAttribType.COLOR),n.insert("attPosition",t.VertexAttribType.POSITION),n.insert("attTexcoord0",t.VertexAttribType.TEXCOORD0),a.semantics=n;const i=new t.RenderState;i.viewport=new t.ViewportState,i.viewport.rect=new t.Rect(0,0,1,1),i.viewport.minDepth=0,i.viewport.maxDepth=1,i.rasterization=new t.RasterizationState;const r=new t.DepthStencilState;r.depthWriteEnable=!1,i.depthstencil=r;const o=new t.ColorBlendState,s=new t.ColorBlendAttachmentState;s.blendEnable=!0,s.srcColorBlendFactor=t.BlendFactor.SRC_ALPHA,s.dstColorBlendFactor=t.BlendFactor.ONE_MINUS_SRC_ALPHA,s.srcAlphaBlendFactor=t.BlendFactor.SRC_ALPHA,s.dstAlphaBlendFactor=t.BlendFactor.ONE_MINUS_SRC_ALPHA,s.ColorBlendOp=t.BlendOp.ADD,s.AlphaBlendOp=t.BlendOp.ADD,o.attachments.pushBack(s),i.colorBlend=o,a.renderState=i;const d=Be.createMaterial(a);return d.renderQueue=1,d.setMat4("u_MVP",new C),d}}class Je{constructor(){this._segProviderMap=new Map,this._cmdBufferHelper=new we}static getInstance(){return null==this._instance&&(this._instance=new Je),this._instance}static getMask(e,t=0){return this.getInstance().getMask(e,t)}init(){this._segProviderMap.set(exports.SegmentationType.Body.toLowerCase(),new et(this)),this._segProviderMap.set(exports.SegmentationType.Head.toLowerCase(),new ot(this)),this._segProviderMap.set(exports.SegmentationType.Sky.toLowerCase(),new tt(this)),this._segProviderMap.set(exports.SegmentationType.Hair.toLowerCase(),new rt(this)),this._segProviderMap.set(exports.SegmentationType.Building.toLowerCase(),new nt(this)),this._segProviderMap.set(exports.SegmentationType.Cloth.toLowerCase(),new at(this)),this._segProviderMap.set(exports.SegmentationType.Ground.toLowerCase(),new it(this)),this._segProviderMap.set(exports.SegmentationType.Hand.toLowerCase(),new st(this))}get cmdBufferHelper(){return this._cmdBufferHelper}onUpdate(e){this._cmdBufferHelper.onPreUpdate();for(const t of this._segProviderMap.values())t.onUpdate(e);this._cmdBufferHelper.onPostUpdate()}createRenderTextureHelper(e){return new Ze(Be.createTexture2D(),Be.createRenderTexture(),Be.createScreenMaterial(e))}createNomralScreenShader(){return Be.createShaders({gles2:{vs:"attribute vec3 inPosition;\n       attribute vec2 inTexCoord;\n       varying vec2 uv;\n       uniform mat4 u_Model;\n       void main() {\n       gl_Position = u_Model * vec4(inPosition, 1.0);\n       uv = inTexCoord;\n       }\n      ",fs:`precision lowp float;
       varying vec2 uv;
       uniform sampler2D tex;
       void main() {
        gl_FragColor = texture2D(tex, uv);
      }
      `},metal:{vs:`
      #include <metal_stdlib>
      #include <simd/simd.h>
  
      using namespace metal;
  
      struct buffer_t
      {
          float4x4 u_Model;
      };
  
      struct main0_out
      {
          float2 uv;
          float4 gl_Position [[position]];
      };
  
      struct main0_in
      {
          float3 inPosition [[attribute(0)]];
          float2 inTexCoord [[attribute(1)]];
      };
  
      vertex main0_out main0(main0_in in [[stage_in]], constant buffer_t& buffer)
      {
          main0_out out = {};
          out.gl_Position = buffer.u_Model * float4(in.inPosition, 1.0);
          out.uv = in.inTexCoord;
          out.gl_Position.z = (out.gl_Position.z + out.gl_Position.w) * 0.5;       // Adjust clip-space for Metal
          return out;
      }
       `,fs:`
      #include <metal_stdlib>
      #include <simd/simd.h>
      
      using namespace metal;
      
      struct main0_out
      {
          float4 gl_FragColor [[color(0)]];
      };
      
      struct main0_in
      {
          float2 uv;
      };
      
      fragment main0_out main0(main0_in in [[stage_in]], texture2d<float> tex [[texture(0)]], sampler texSmplr [[sampler(0)]])
      {
          main0_out out = {};
          out.gl_FragColor = tex.sample(texSmplr, in.uv);
          return out;
      }    
       `}})}getMask(e,t){const a=this._segProviderMap.get(e.toLowerCase());return a?a.getMask(t):(console.error(`Segmentation doesn't support ${e} yet`),null)}}class Ze{constructor(e,t,a){this.texture=e,this.renderTexture=t,this.screenMaterial=a}}class $e{constructor(e){this._mgr=e,this._texture=null}}class et extends $e{onUpdate(){var e;if(null==this._texture)return;const a=null==(e=Ua.engine)?void 0:e.algoritms.nativeResult,n=a.getBgInfo(),i=this.getOrCreateTexture();null==n?i.storage(new t.Image):i.storage(n.bgMask)}getOrCreateTexture(){return null==this._texture&&(this._texture=new t.Texture2D),this._texture}getMask(){return this.getOrCreateTexture()}}class tt extends $e{onUpdate(){var e;if(null==this._texture)return;const a=null==(e=Ua.engine)?void 0:e.algoritms.nativeResult,n=a.getSkyInfo(),i=this.getOrCreateTexture();null==n?i.storage(new t.Image):i.storage(n.skyMask)}getOrCreateTexture(){return null==this._texture&&(this._texture=new t.Texture2D),this._texture}getMask(){return this.getOrCreateTexture()}}class at extends $e{onUpdate(){var e;if(null==this._texture)return;const a=null==(e=Ua.engine)?void 0:e.algoritms.nativeResult,n=a.getClothesSegInfo(),i=this.getOrCreateTexture();null==n?i.storage(new t.Image):i.storage(n.alphaMask)}getOrCreateTexture(){return null==this._texture&&(this._texture=new t.Texture2D),this._texture}getMask(){return this.getOrCreateTexture()}}class nt extends $e{constructor(){super(...arguments),this._initialized=!1}onUpdate(){var e;if(!this._initialized)return;const a=null==(e=Ua.engine)?void 0:e.algoritms.nativeResult,n=a.getBuildingSegInfo(),i=this.getOrCreateTexture();null==n?i.storage(new t.Image):i.storage(n.mask),this._screenMaterial.setTex("tex",i),this._mgr.cmdBufferHelper.cmdBufferSetRenderTexture(this._renderTexture),this._mgr.cmdBufferHelper.cmdBufferDrawMesh(this._mgr.cmdBufferHelper.screenMesh,new C,this._screenMaterial,0,0,new t.MaterialPropertyBlock)}getOrCreateTexture(){return null==this._texture&&(this._texture=new t.Texture2D),this._texture}getMask(){return this.tryToInit(),this._renderTexture}tryToInit(){if(this._initialized)return;this._initialized=!0,this._renderTexture=Be.createRenderTexture();const e=Be.createShaders({gles2:{vs:"attribute vec3 inPosition;\n      attribute vec2 inTexCoord;\n      varying vec2 uv; \n      uniform mat4 u_Model;\n      void main() {\n        gl_Position = u_Model * vec4(inPosition, 1.0);\n        uv = inTexCoord;\n      }\n      ",fs:`precision lowp float;
      varying vec2 uv;
      uniform sampler2D tex;
      void main() {
        vec4 color = texture2D(tex, uv);
        gl_FragColor = vec4(color.g, color.g, color.g, 1.0);
      } 
      `},metal:{vs:`
      #include <metal_stdlib>
      #include <simd/simd.h>
      
      using namespace metal;
      
      struct buffer_t
      {
          float4x4 u_Model;
      };
      
      struct main0_out
      {
          float2 uv;
          float4 gl_Position [[position]];
      };
      
      struct main0_in
      {
          float3 inPosition [[attribute(0)]];
          float2 inTexCoord [[attribute(1)]];
      };
      
      vertex main0_out main0(main0_in in [[stage_in]], constant buffer_t& buffer)
      {
          main0_out out = {};
          out.gl_Position = buffer.u_Model * float4(in.inPosition, 1.0);
          out.uv = in.inTexCoord;
          out.gl_Position.z = (out.gl_Position.z + out.gl_Position.w) * 0.5;       // Adjust clip-space for Metal
          return out;
      }    
      `,fs:`
    #include <metal_stdlib>
    #include <simd/simd.h>

    using namespace metal;

    struct main0_out
    {
        float4 gl_FragColor [[color(0)]];
    };

    struct main0_in
    {
        float2 uv;
    };

    fragment main0_out main0(main0_in in [[stage_in]], texture2d<float> tex [[texture(0)]], sampler texSmplr [[sampler(0)]])
    {
        main0_out out = {};
        float4 color = tex.sample(texSmplr, in.uv);
        out.gl_FragColor = float4(color.y, color.y, color.y, 1.0);
        return out;
    }
      `}});this._screenMaterial=Be.createScreenMaterial(e)}}class it extends $e{onUpdate(){var e;if(null==this._texture)return;const a=null==(e=Ua.engine)?void 0:e.algoritms.nativeResult,n=a.getGroundSegInfo(),i=this.getOrCreateTexture();null==n?i.storage(new t.Image):i.storage(n.groundMask)}getOrCreateTexture(){return null==this._texture&&(this._texture=new t.Texture2D),this._texture}getMask(){return this.getOrCreateTexture()}}class rt extends $e{onUpdate(){var e;if(null==this._texture)return;const a=null==(e=Ua.engine)?void 0:e.algoritms.nativeResult.getHairInfo(),n=this.getOrCreateTexture();null==a?n.storage(new t.Image):n.storage(a.mask)}getOrCreateTexture(){return null==this._texture&&(this._texture=new t.Texture2D),this._texture}getMask(){return this.getOrCreateTexture()}}class ot extends $e{constructor(e){super(e),this._rdMap=new Map}onUpdate(){var e;const t=null==(e=Ua.engine)?void 0:e.algoritms.nativeResult;for(let e=0;e<t.getHeadSegInfoCount();++e)this.getOrCreateRnderTextureHelper(e);for(const e of this._rdMap.keys())this.updateMask(t.getHeadSegInfo(e),this._rdMap.get(e))}getMask(e){var t;return null==(t=this.getOrCreateRnderTextureHelper(e))?void 0:t.renderTexture}getOrCreateRnderTextureHelper(e){return this._rdMap.has(e)||this._rdMap.set(e,this._mgr.createRenderTextureHelper(this._mgr.createNomralScreenShader())),this._rdMap.get(e)}updateMask(e,a){if(null!=a){const n=new C;if(this._mgr.cmdBufferHelper.cmdBufferSetRenderTexture(a.renderTexture),this._mgr.cmdBufferHelper.cmdBufferClearRenderTexture(!0,!1,new t.Color(0,0,0,0),1),null!=e){a.texture.storage(e.alpha);const i=e.width,r=e.height,o=e.srcWidth,s=e.srcHeight,d=e.matrix,l=d.get(0),c=d.get(1),p=d.get(2),u=d.get(3),m=d.get(4),g=d.get(5),_=new C(l,u,0,0,c,m,0,0,0,0,1,0,p,g,0,1);_.invert_Full();const f=new C(i/2,0,0,0,0,r/2,0,0,0,0,1,0,i/2,r/2,0,1),h=new C;C.multiplyMatrices4x4(_,f,h);const y=new C(2/o,0,0,0,0,2/s,0,0,0,0,1,0,-1,-1,0,1);C.multiplyMatrices4x4(y,h,n),a.screenMaterial.setTex("tex",a.texture),this._mgr.cmdBufferHelper.cmdBufferDrawMesh(this._mgr.cmdBufferHelper.screenMesh,n,a.screenMaterial,0,0,new t.MaterialPropertyBlock)}}}}class st extends $e{constructor(e){super(e),this._handMap=new Map}onUpdate(){var e;const a=null==(e=Ua.engine)?void 0:e.algoritms.nativeResult;for(let e=0;e<a.getHandCount();++e)this.getOrCreateTexture(e);for(const e of this._handMap.keys())if(null==a.getHandInfo(e)){var n;null==(n=this._handMap.get(e))?void 0:n.storage(new t.Image)}else{var i;null==(i=this._handMap.get(e))?void 0:i.storage(a.getHandInfo(e).image)}}getOrCreateTexture(e){return this._handMap.has(e)||this._handMap.set(e,new t.Texture2D),this._handMap.get(e)}getMask(e){return this.getOrCreateTexture(e)}}class dt{constructor(e){var a;const n=e.properties;this._segType=n.segmentationType.toLowerCase(),this._smoothness=n.smoothness,this._invert=n.invert,this._useCutoutTexture=n.useCutoutTexture,this._cutoutTexture=n.cutoutTexture,this._cutoutTextureInverseY=n.cutoutTextureInverseY,this._renderTexture=null==(a=Ua.engine)?void 0:a.customAssets.getNativeObject(e.uuid),this._renderTexture.depth=1,this._renderTexture.width=t.AmazingManager.getSingleton("BuiltinObject").getInputTextureWidth(),this._renderTexture.height=t.AmazingManager.getSingleton("BuiltinObject").getInputTextureHeight(),this._renderTexture.filterMag=t.FilterMode.LINEAR,this._renderTexture.filterMin=t.FilterMode.LINEAR,this._renderTexture.filterMipmap=t.FilterMipmapMode.NONE,this._renderTexture.attachment=t.RenderTextureAttachment.NONE;const i=Be.createShaders({gles2:{vs:"attribute vec3 inPosition;\n    attribute vec2 inTexCoord;\n    varying vec2 uv;\n    uniform mat4 u_Model;\n    void main() {\n      gl_Position = u_Model * vec4(inPosition, 1.0);\n      uv = inTexCoord;\n    }\n    ",fs:`precision highp float;
    varying vec2 uv;
    uniform sampler2D u_mask;
    uniform float u_smoothness;
    uniform float u_invert;
    uniform float u_useCutoutTexture;
    uniform float u_cutoutTextureInverseY;
    uniform sampler2D u_cutoutTex;
    uniform sampler2D u_mask2;
    uniform float u_useMask2;
    void main() {
      float maskAlpha = texture2D(u_mask, uv).r;
      if (u_useMask2 > 0.5) {
        maskAlpha += texture2D(u_mask2, uv).r;
      }
      maskAlpha = smoothstep(0.0 + (u_smoothness),1.0,maskAlpha);
      if(u_invert > 0.5) {
        maskAlpha = 1.0 - maskAlpha;
      }
      if (u_useCutoutTexture > 0.5) {
        if (u_cutoutTextureInverseY > 0.5) {
          gl_FragColor = maskAlpha * texture2D(u_cutoutTex, vec2(uv.x, 1.0 - uv.y));
        } else {
          gl_FragColor = maskAlpha * texture2D(u_cutoutTex, uv);
        }
        gl_FragColor.a = maskAlpha;
      } else {
        gl_FragColor = vec4(maskAlpha, maskAlpha, maskAlpha, 1.0);
      }
    }
    `},metal:{vs:`
    #include <metal_stdlib>
    #include <simd/simd.h>

    using namespace metal;

    struct buffer_t
    {
        float4x4 u_Model;
    };

    struct main0_out
    {
        float2 uv;
        float4 gl_Position [[position]];
    };

    struct main0_in
    {
        float3 inPosition [[attribute(0)]];
        float2 inTexCoord [[attribute(1)]];
    };

    vertex main0_out main0(main0_in in [[stage_in]], constant buffer_t& buffer)
    {
        main0_out out = {};
        out.gl_Position = buffer.u_Model * float4(in.inPosition, 1.0);
        out.uv = in.inTexCoord;
        out.gl_Position.z = (out.gl_Position.z + out.gl_Position.w) * 0.5;       // Adjust clip-space for Metal
        return out;
    }
    `,fs:`
    #include <metal_stdlib>
    #include <simd/simd.h>

    using namespace metal;

    struct buffer_t
    {
        float u_useMask2;
        float u_smoothness;
        float u_invert;
        float u_useCutoutTexture;
        float u_cutoutTextureInverseY;
    };

    struct main0_out
    {
        float4 gl_FragColor [[color(0)]];
    };

    struct main0_in
    {
        float2 uv;
    };

    fragment main0_out main0(main0_in in [[stage_in]], constant buffer_t& buffer, texture2d<float> u_mask [[texture(0)]], texture2d<float> u_mask2 [[texture(1)]], texture2d<float> u_cutoutTex [[texture(2)]], sampler u_maskSmplr [[sampler(0)]], sampler u_mask2Smplr [[sampler(1)]], sampler u_cutoutTexSmplr [[sampler(2)]])
    {
        main0_out out = {};
        float maskAlpha = u_mask.sample(u_maskSmplr, in.uv).x;
        if (buffer.u_useMask2 > 0.5)
        {
            maskAlpha += u_mask2.sample(u_mask2Smplr, in.uv).x;
        }
        maskAlpha = smoothstep(0.0 + buffer.u_smoothness, 1.0, maskAlpha);
        if (buffer.u_invert > 0.5)
        {
            maskAlpha = 1.0 - maskAlpha;
        }
        if (buffer.u_useCutoutTexture > 0.5)
        {
            if (buffer.u_cutoutTextureInverseY > 0.5)
            {
                out.gl_FragColor = maskAlpha * u_cutoutTex.sample(u_cutoutTexSmplr, float2(in.uv.x, 1.0 - in.uv.y));
            }
            else
            {
                out.gl_FragColor = maskAlpha * u_cutoutTex.sample(u_cutoutTexSmplr, in.uv);
            }
            out.gl_FragColor.w = maskAlpha;
        }
        else
        {
            out.gl_FragColor = float4(maskAlpha, maskAlpha, maskAlpha, 1.0);
        }
        return out;
    }
    `}});if(this._screenMaterial=Be.createScreenMaterial(i),this._screenMaterial.setTex("u_mask",Je.getMask(this._segType)),this._screenMaterial.setFloat("u_smoothness",.9*(1-this._smoothness)),this._screenMaterial.setFloat("u_invert",!0===this._invert?1:0),!0===this._useCutoutTexture){const e=Ua.engine.assets.loadSync(this._cutoutTexture);null!=e&&(this._useCutoutTexture=!0,this._screenMaterial.setTex("u_cutoutTex",e.resource),this._screenMaterial.setFloat("u_cutoutTextureInverseY",!0===this._cutoutTextureInverseY?1:0))}this._screenMaterial.setFloat("u_useCutoutTexture",!0===this._useCutoutTexture?1:0),this._segType===exports.SegmentationType.Head.toLocaleLowerCase()||this._segType===exports.SegmentationType.Hand.toLocaleLowerCase()?(this._screenMaterial.setFloat("u_useMask2",1),this._screenMaterial.setTex("u_mask2",Je.getMask(this._segType,1))):this._screenMaterial.setFloat("u_useMask2",0)}onUpdate(){const e=Ua.engine.customAssets.cmdBufferHelper;e.cmdBufferSetRenderTexture(this._renderTexture),e.cmdBufferDrawMesh(e.screenMesh,new C,this._screenMaterial,0,0,new t.MaterialPropertyBlock)}get type(){return exports.AssetSubType.Segmentation}onDestroy(){}onLateUpdate(){}onStart(){}}class lt{constructor(e){var a;const n=e.properties;if(this._builtinObject=t.AmazingManager.getSingleton("BuiltinObject"),this._outputTexture=null==(a=Ua.engine)?void 0:a.customAssets.getNativeObject(e.uuid),this._outputTexture.depth=1,this._outputTexture.filterMag=t.FilterMode.LINEAR,this._outputTexture.filterMin=t.FilterMode.LINEAR,this._outputTexture.filterMipmap=t.FilterMipmapMode.NONE,this._outputTexture.attachment=t.RenderTextureAttachment.NONE,this._textureKey=n.textureKey,n.defaultImagePath){var i,r;this._defaultTexture=null==(i=Ua.engine)||null==(r=i.assets.loadSync(n.defaultImagePath))?void 0:r.resource,this._defaultTexture||console.error("Image Picker default texture load failure")}}updateOutputTexture(){var e;const t=null==(e=Ua.engine)?void 0:e.customAssets.cmdBufferHelper,a=this._builtinObject.getUserTexture(this._textureKey);a?(this._outputTexture.width=a.width,this._outputTexture.height=a.height,t.cmdBufferBlit(a,this._outputTexture)):this._defaultTexture&&(this._outputTexture.width=this._defaultTexture.width,this._outputTexture.height=this._defaultTexture.height,t.cmdBufferBlit(this._defaultTexture,this._outputTexture))}onUpdate(){this.updateOutputTexture()}onStart(){this.updateOutputTexture()}onLateUpdate(){}onDestroy(){}}class ct{constructor(e){var t;const a=e.properties;this._faceIndex=a.faceIndex,this._path=a.path,this._faceMesh=null==(t=Ua.engine)?void 0:t.customAssets.getNativeObject(e.uuid);const n=Ua.engine.assets.loadSync(this._path);if(null!==n){const e=n.resource.clone();this._faceMesh.assetMgr=e.assetMgr,this._faceMesh.name=e.name,this._faceMesh.boundingBox=e.boundingBox,this._faceMesh.instanceData=e.instanceData,this._faceMesh.instanceDataStride=e.instanceDataStride,this._faceMesh.materialIndex=e.materialIndex,this._faceMesh.morphers=e.morphers,this._faceMesh.skin=e.skin,this._faceMesh.submeshes=e.submeshes,this._faceMesh.vertexAttribs=e.vertexAttribs,this._faceMesh.vertices=e.vertices,this._faceMesh.seqMesh=e.seqMesh,this._faceMesh.originalVertices=e.originalVertices,this._faceMesh.clearAfterUpload=e.clearAfterUpload,this._faceMesh.setVertexCount(e.getVertexCount()),0!==e.getVertexArray(0,0).size()&&this._faceMesh.setVertexArray(e.getVertexArray(0,0),0,0,!0),0!==e.getNormalArray(0,0).size()&&this._faceMesh.setNormalArray(e.getNormalArray(0,0),0,0),0!==e.getTangentArray(0,0).size()&&this._faceMesh.setTangentArray(e.getTangentArray(0,0),0,0),0!==e.getColorArray(0,0).size()&&this._faceMesh.setColorArray(e.getColorArray(0,0),0,0),0!==e.getUvArray(0,0,0).size()&&this._faceMesh.setUvArray(0,e.getUvArray(0,0,0),0,0),0!==e.getUv3DArray(0,0,0).size()&&this._faceMesh.setUv3DArray(0,e.getUv3DArray(0,0,0),0,0),0!==e.getUserDefineArray(0,0,0).size()&&this._faceMesh.setUserDefineArray(0,e.getUserDefineArray(0,0,0),0,0),this.setUpMorpher(this._faceMesh,!1)}else console.error("face mesh asset: mesh not found!")}onDestroy(){}onStart(){}onUpdate(){if(null!==this._faceMesh){const e=Xe.faces,t=e.length;if((0>this._faceIndex||5<this._faceIndex)&&(this._faceIndex=0),t<=this._faceIndex)return;const a=e[this._faceIndex].faceMesh;if(null===a)return;const n=a.vertexes,i=a.normals;null!==n&&null!==i&&0<n.size()&&0<i.size()&&(this._faceMesh.setVertexArray(n),this._faceMesh.setNormalArray(i),this.setUpMorpher(this._faceMesh,!0))}}onLateUpdate(){}setUpMorpher(e,t){if(null!==e){const a=Ua.engine.scene.native,n=a.entities;for(let a=0;a<n.size();a++){const i=n.get(a),r=i.getComponent("MorpherComponent");if(null!==r&&r.basemesh.handle===e.handle)if(!t){const t=r.channelWeights.clone(),a=t.getVectorKeys(),n=r.channelAmplifiers.clone(),o=n.getVectorKeys();r.basemesh=null,r.basemesh=e;const s=r.channelWeights,d=r.channelAmplifiers;for(let e=0;e<t.size();e++)s.set(a.get(e),t.get(a.get(e)));for(let e=0;e<n.size();e++)d.set(o.get(e),n.get(o.get(e)))}else r.basemesh=e}}}}const pt=new Map([[exports.AssetSubType.CameraInput.toLowerCase(),ze],[exports.AssetSubType.Face.toLowerCase(),Qe],[exports.AssetSubType.Segmentation.toLowerCase(),dt],[exports.AssetSubType.ImagePicker.toLowerCase(),lt]]),ut=new Map([[exports.AssetSubType.Face.toLowerCase(),ct]]),mt=new Map([[exports.AssetType.Texture.toLowerCase(),pt],[exports.AssetType.Mesh.toLowerCase(),ut]]);function gt(e){const t=new Uint8Array(e);return String.fromCharCode.apply(null,t)}class _t{constructor(){this._resEntryMap=new Map,this._assets=[],this._nativeObjMap=new t.Map,this._cmdBufferHelper=new we}getNativeObject(e){return this._nativeObjMap.get(e)}init(){var e;const t=null==(e=Ua.engine)?void 0:e.scene.native;if(null==t)return;const a=t.assetMgr.rootDir+"customAssets.json",n=fs.accessSync(a,0);if(!n)return void console.log("No customAssets.json found");const i=fs.readFileSync(a);if(this._assetsConfig=JSON.parse(gt(i)),null!=this._assetsConfig){this._nativeObjMap=t.assetMgr.getAllScriptCustomAssets();for(const e of this._assetsConfig)this._resEntryMap.set(e.uuid,e);const e=this.analyzeAssetsDependency();for(const t of e){const e=this._resEntryMap.get(t),a=this.createCustomAsset(e);a&&this._assets.push(a)}}}get cmdBufferHelper(){return this._cmdBufferHelper}update(e){this._cmdBufferHelper.onPreUpdate();for(const t of this._assets)t.onUpdate(e);this._cmdBufferHelper.onPostUpdate()}start(){for(const e of this._assets)e.onStart()}destroy(){for(const e of this._assets)e.onDestroy()}lateUpdate(e){for(const t of this._assets)t.onLateUpdate(e)}createCustomAsset(e){const t=mt.get(e.type.toLowerCase());if(null==t)return console.error(`Custom asset doesn't support asset type: [${e.type}]`),null;const a=t.get(e.subType.toLowerCase());return null==a?(console.error(`[${e.type}] custom asset doesn't support asset subtype: [${e.subtype}]`),null):new a(e)}analyzeAssetsDependency(){let e=[];const t=new Map,a=new Map,n="custom://";let i=0;for(const e of this._assetsConfig)i+=1,a.set(e.uuid,0);for(const e of this._assetsConfig){const i=e.uuid;if(e.properties)for(const r in e.properties){const o=e.properties[r];if("string"==typeof o&&o.startsWith(n)){const e=o.substr(n.length);console.log(`custom assets: [${i}] depends on [${e}]`),a.set(e,a.get(e)+1),t.has(i)||t.set(i,[]),t.get(i).push(e)}}}const r=[];for(const e of a.keys())0===a.get(e)&&r.push(e);for(;0<r.length;){const n=r.shift();if(e.push(n),t.has(n))for(const e of t.get(n))a.set(e,a.get(e)-1),0===a.get(e)&&r.push(e)}if(e.length===i)e.reverse();else{console.error("Found circular dependency in custom assets"),e=[];for(const t of this._assetsConfig)e.push(t.uuid)}return e}}class ft{constructor(e,t){this._inputs=[void 0],this._outputs=[void 0],this._properties=new Map,this._needUpdateTexture=!0,this._name=e,this.deserialize({name:e,class:this.constructor.name,properties:t}),this._init()}getInput(e){return this._inputs[e]}getOutput(e){return this._outputs[e]}set needUpdateTexture(e){this._needUpdateTexture=e}get needUpdateTexture(){return this._needUpdateTexture}get inputSize(){return this._inputs.length}get outputSize(){return this._outputs.length}_init(){console.log(`[JS GPUFilter] Initialize filter ${this.constructor.name} with properties ${JSON.stringify(this.serialize())}`)}setInput(e,t=0){return t>this._inputs.length?void console.warn(`[JS GPUFilter] Index exceed input slot capacity!`):void(this._inputs[t]=e)}addInput(e){this._inputs.push(e)}addOutput(e){this._outputs.push(e)}setOutput(e,t=0){return t>this._outputs.length?void console.warn(`[JS GPUFilter] Index exceed output slot capacity!`):void(this._outputs[t]=e)}get name(){return this._name}get prop(){return this._properties}setProp(e,t){this._properties.set(e,t)}getProp(e){return this._properties.get(e)}deserialize(e){if(this.constructor.name!==e.class)return void console.error(`[JS GPUFilter] Cannot deserialize json: types [${this.constructor.name} vs ${e.class}] mismatch`);this._name=e.name||"";const t=e.properties||{};for(const a in t)this.setProp(a,t[a])}serialize(){const e={};return this._properties.forEach((t,a)=>{e[a]=t}),{name:this._name,class:this.constructor.name,properties:e}}render(){}isReady(){return this.isInputsReady()&&this.isOutputsReady()&&this._inputs[0]!==this._outputs[0]}isInputsReady(){for(let e=0;e<this._inputs.length;++e)if(!this._inputs[e])return!1;return!0}isOutputsReady(){return this._outputs[0]!=null}clear(){for(let e=0;e<this._inputs.length;++e)this._inputs[e]=void 0;for(let e=0;e<this._outputs.length;++e)this._outputs[e]=void 0}getOutRTInfo(e=0,t){var a=Math.floor,n;const i=null==(n=this._inputs[0])?t:n;if(void 0===i)return new Error("Cannot get output render target info because there is no input.");const r=this.getProp("widthScalar")?this.getProp("widthScalar"):1,o=this.getProp("heightScalar")?this.getProp("heightScalar"):1;let s=a(i.width*r),d=a(i.height*o);return this.getProp("width")&&(s=this.getProp("width")),this.getProp("height")&&(d=this.getProp("height")),{width:s,height:d,colorFormat:i.colorFormat,filterMode:i.filterMag}}}class ht{constructor(e,t,a,n,r=8){this.occupied=[],this.available=[],this.maxCapacity=8,this.width=0,this.height=0,this.format=i.RGBA8Unorm,this.filterMode=exports.TextureFilterMode.Linear,this.width=e,this.height=t,this.format=a,this.filterMode=n,this.maxCapacity=r}clear(){this.occupied.length=0,this.available.length=0}createTexture(){return Be.createRenderTexturePlus(this.width,this.height,this.format,this.filterMode)}balance(){return this.occupied.length+this.available.length}get(){if(0<this.available.length){const e=this.available[this.available.length-1];return this.available.pop(),this.occupied.push(e),e}if(this.available.length+this.occupied.length<this.maxCapacity){const e=this.createTexture();return this.occupied.push(e),e}return new Error(`[JS GPUFilter] texture pool exceed capacity ${this.maxCapacity} limit!`)}return(e){const t=this.occupied.indexOf(e);let a;0<=t&&(a=this.occupied[t],this.occupied[t]=this.occupied[this.occupied.length-1],this.occupied.pop());const n=this.available.indexOf(e);0>n&&a&&this.available.push(a)}returnAll(){for(;0<this.occupied.length;){const e=this.occupied[this.occupied.length-1];this.available.push(e),this.occupied.pop()}}}class yt{constructor(e){this._pool=new Map,this._capacity=e}getKey(e,t,a,n){return`${e}-${t}-${a}-${n}`}get(e,t,a,n){const i=this.getKey(e,t,a,n);return this._pool.has(i)||this._pool.set(i,new ht(e,t,a,n,this._capacity)),this._pool.get(i).get()}getUniformPool(e,t,a,n){const i=this.getKey(e,t,a,n);return this._pool.has(i)?this._pool.get(i):void 0}return(e){if(void 0===e)return;const t=e.width,a=e.height,n=e.colorFormat,i=e.filterMin,r=this.getKey(t,a,n,i);this._pool.has(r)&&this._pool.get(r).return(e)}clearAll(){for(const e in this._pool){const t=this._pool.get(e);t.clear()}this._pool.clear()}returnAll(){this._pool.forEach(e=>{e.returnAll()})}totalBalance(){let e=0;return this._pool.forEach((t,a)=>{const n=this._pool.get(a);e+=n.balance()}),e}}class vt extends ft{onUpdate(e,t){this.needUpdateTexture&&this.getOutput(0)&&this.getInput(0)&&(t.blit(this.getInput(0),this.getOutput(0)),this.needUpdateTexture=!1)}}class Tt{static getMetal(e,t=void 0){switch(e){case"common.vs":return`
          #include <metal_stdlib>
#include <simd/simd.h>

using namespace metal;

struct main0_out
{
    float2 uv;
    float4 gl_Position [[position]];
};

struct main0_in
{
    float3 inPosition [[attribute(0)]];
    float2 inTexCoord [[attribute(1)]];
};

vertex main0_out main0(main0_in in [[stage_in]])
{
    main0_out out = {};
    out.gl_Position = float4(in.inPosition, 1.0);
    out.uv = in.inTexCoord;
    out.gl_Position.z = (out.gl_Position.z + out.gl_Position.w) * 0.5;       // Adjust clip-space for Metal
    return out;
}
        `;case"mask.fs":return`
          #include <metal_stdlib>
#include <simd/simd.h>

using namespace metal;

/* struct buffer_t */
/* { */
/*     int uMaskFlipY; */
/*     int uFlipY; */
/* }; */

struct main0_out
{
    float4 gl_FragColor [[color(0)]];
};

struct main0_in
{
    float2 uv;
};

fragment main0_out main0(main0_in in [[stage_in]], texture2d<float> u_inputTex [[texture(0)]], texture2d<float> u_maskTex [[texture(1)]], sampler u_inputTexSmplr [[sampler(0)]], sampler u_maskTexSmplr [[sampler(1)]], 
    constant int& uMaskFlipY [[buffer(0)]],
    constant int& uFlipY [[buffer(1)]]
                        )
{
    main0_out out = {};
    float2 uv1 = in.uv;
    if (uMaskFlipY > 0)
    {
        uv1.y = 1.0 - uv1.y;
    }
    float2 uv2 = in.uv;
    if (uFlipY > 0)
    {
        uv2.y = 1.0 - uv2.y;
    }
    float3 texDest = u_inputTex.sample(u_inputTexSmplr, uv2).xyz;
    float texMask = u_maskTex.sample(u_maskTexSmplr, uv1).x;
    out.gl_FragColor = float4(texDest, clamp(texMask, 0.0, 1.0));
    return out;
}
        `;case"laplacian.fs":{const{hammersleyNumSample:e}=t;return`
          #pragma clang diagnostic ignored "-Wmissing-prototypes"
#pragma clang diagnostic ignored "-Wmissing-braces"

#include <metal_stdlib>
#include <simd/simd.h>

using namespace metal;

template<typename T, size_t Num>
struct spvUnsafeArray
{
    T elements[Num ? Num : 1];
    
    thread T& operator [] (size_t pos) thread
    {
        return elements[pos];
    }
    constexpr const thread T& operator [] (size_t pos) const thread
    {
        return elements[pos];
    }
    
    device T& operator [] (size_t pos) device
    {
        return elements[pos];
    }
    constexpr const device T& operator [] (size_t pos) const device
    {
        return elements[pos];
    }
    
    constexpr const constant T& operator [] (size_t pos) const constant
    {
        return elements[pos];
    }
    
    threadgroup T& operator [] (size_t pos) threadgroup
    {
        return elements[pos];
    }
    constexpr const threadgroup T& operator [] (size_t pos) const threadgroup
    {
        return elements[pos];
    }
};

/* struct buffer_t */
/* { */
/*     float uMaskThreshold; */
/*     float2 uDestTextureSize; */
/*     float uIteration; */
/*     float uLevel; */
/*     spvUnsafeArray<float2, ${0|e}> u_hammersley; */
/*     float2 uBlurScale; */
/* }; */

struct main0_out
{
    float4 gl_FragColor [[color(0)]];
};

struct main0_in
{
    float2 uv;
};

static inline __attribute__((always_inline))
float2 hash22(thread const float2& p)
{
    float3 p3 = fract(float3(p.xyx) * float3(0.103100001811981201171875, 0.10300000011920928955078125, 0.097300000488758087158203125));
    p3 += float3(dot(p3, p3.yzx + float3(33.3300018310546875)));
    return fract((p3.xx + p3.yz) * p3.zy);
}

fragment main0_out main0(main0_in in [[stage_in]], texture2d<float> uDestinationTexture [[texture(0)]], texture2d<float> uPrevLvlPassTexture [[texture(1)]], texture2d<float> uPrevPassTexture [[texture(2)]], sampler uDestinationTextureSmplr [[sampler(0)]], sampler uPrevLvlPassTextureSmplr [[sampler(1)]], sampler uPrevPassTextureSmplr [[sampler(2)]], 
    constant float& uMaskThreshold [[buffer(0)]],
    constant float2& uDestTextureSize [[buffer(1)]],
    constant float& uIteration [[buffer(2)]],
    constant float& uLevel [[buffer(3)]],
    constant spvUnsafeArray<float2, ${0|e}>& u_hammersley [[buffer(4)]],
    constant float2& uBlurScale [[buffer(5)]]
                         
                        )
{
    main0_out out = {};
    float4 outColor = uDestinationTexture.sample(uDestinationTextureSmplr, in.uv);
    if (outColor.w > uMaskThreshold)
    {
        float2 param = in.uv * 1000.0;
        float2 rnd = hash22(param);
        float2 texDestSize = uDestTextureSize;
        float minSide = min(texDestSize.x, texDestSize.y);
        if ((uIteration < 9.9999997473787516355514526367188e-05) && (uLevel < 9.9999997473787516355514526367188e-05))
        {
            float2 ratio = texDestSize / float2(minSide);
            float rangeStep = 0.100000001490116119384765625;
            float range = 0.0199999995529651641845703125;
            float weightSum = 0.0;
            float3 sum = float3(0.0);
            for (int j = 0; j < ${0|e}; j++)
            {
                weightSum = 0.0;
                sum = float3(0.0);
                for (int i = 0; i < ${0|e}; i++)
                {
                    float2 hUv = ratio * (u_hammersley[i]);
                    float2 sUv = in.uv + ((fract(hUv + rnd) - float2(0.5)) * range);
                    bool _158 = sUv.x < 0.0;
                    bool _166;
                    if (!_158)
                    {
                        _166 = sUv.x > 1.0;
                    }
                    else
                    {
                        _166 = _158;
                    }
                    bool _173;
                    if (!_166)
                    {
                        _173 = sUv.y < 0.0;
                    }
                    else
                    {
                        _173 = _166;
                    }
                    bool _180;
                    if (!_173)
                    {
                        _180 = sUv.y > 1.0;
                    }
                    else
                    {
                        _180 = _173;
                    }
                    if (_180)
                    {
                        continue;
                    }
                    float4 rndTex = uDestinationTexture.sample(uDestinationTextureSmplr, sUv);
                    if (rndTex.w < uMaskThreshold)
                    {
                        sum += rndTex.xyz;
                        weightSum += 1.0;
                    }
                }
                if (weightSum > 0.5)
                {
                    break;
                }
                range += rangeStep;
            }
            outColor = float4(sum / float3(weightSum), 1.0);
        }
        else
        {
            if ((uIteration < 9.9999997473787516355514526367188e-05) && (uLevel > 9.9999997473787516355514526367188e-05))
            {
                outColor = uPrevLvlPassTexture.sample(uPrevLvlPassTextureSmplr, in.uv);
            }
            else
            {
                float2 ratioRcp = float2(minSide) / texDestSize;
                float3 ret = float3(0.0);
                float size = 4.0;
                float _244 = -size;
                for (float i_1 = _244; i_1 <= size; i_1 += 1.0)
                {
                    if (abs(i_1) < 0.5)
                    {
                        continue;
                    }
                    float4 smpl = uPrevPassTexture.sample(uPrevPassTextureSmplr, (in.uv + ((uBlurScale * i_1) * ratioRcp)));
                    float weight = ((size + 1.0) - abs(i_1)) / 20.0;
                    ret += (smpl.xyz * weight);
                }
                outColor = float4(ret, 1.0);
                float3 _304 = outColor.xyz + float3((((rnd.x + rnd.y) - 1.0) / 255.0) / 20.0);
                outColor = float4(_304.x, _304.y, _304.z, outColor.w);
            }
        }
    }
    out.gl_FragColor = outColor;
    return out;
}
        `}case"resolve.fs":return`
          #include <metal_stdlib>
#include <simd/simd.h>

using namespace metal;

/* struct buffer_t */
/* { */
/*     int uMaskFlipY; */
/*     float uMaskThreshold; */
/* }; */

struct main0_out
{
    float4 gl_FragColor [[color(0)]];
};

struct main0_in
{
    float2 uv;
};

fragment main0_out main0(main0_in in [[stage_in]], texture2d<float> uTopLevelTexture [[texture(0)]], texture2d<float> u_maskTex [[texture(1)]], sampler uTopLevelTextureSmplr [[sampler(0)]], sampler u_maskTexSmplr [[sampler(1)]], 
    constant int& uMaskFlipY [[buffer(0)]],
    constant float& uMaskThreshold [[buffer(1)]]
                        )
{
    main0_out out = {};
    float2 uv1 = in.uv;
    if (uMaskFlipY > 0)
    {
        uv1.y = 1.0 - uv1.y;
    }
    float4 tex = uTopLevelTexture.sample(uTopLevelTextureSmplr, in.uv);
    float mask = u_maskTex.sample(u_maskTexSmplr, uv1).x;
    if (mask < uMaskThreshold)
    {
        discard_fragment();
    }
    float alpha = (tex.w - uMaskThreshold) / (1.0 - uMaskThreshold);
    tex.w = clamp(alpha, 0.0, 1.0);
    out.gl_FragColor = tex;
    return out;
}
        `;case"grow.fs":{let e="";for(let t=-1;1>=t;++t)for(let a=-1;1>=a;++a)e+=`
              if (maskTexture.sample(maskTextureSmplr, (in.uv + (u_texelSize * float2(${0|t}, ${0|a}))))[u_channelIndex] > u_threshold)
    {
        out.gl_FragColor = float4(1.0);
        return out;
    }
                        `;return`
          #include <metal_stdlib>
#include <simd/simd.h>

using namespace metal;

/* struct buffer_t */
/* { */
/*     float2 u_texelSize; */
/*     int u_channelIndex; */
/*     float u_threshold; */
/* }; */

struct main0_out
{
    float4 gl_FragColor [[color(0)]];
};

struct main0_in
{
    float2 uv;
};

fragment main0_out main0(main0_in in [[stage_in]], texture2d<float> maskTexture [[texture(0)]], sampler maskTextureSmplr [[sampler(0)]], 
                         constant float2& u_texelSize [[buffer(0)]],
                         constant int& u_channelIndex [[buffer(1)]],
                         constant float& u_threshold [[buffer(2)]]
                        )
{
    main0_out out = {};
    ${e}
    out.gl_FragColor = float4(0.0);
    return out;
}
                `}case"operator.fs":{const{snippetMetal:e,operandNum:a,declMetal:n}=t;let r="",o="",s="";for(let e=0;e<a;++e)r+=`, texture2d<float> u_inputTex${e} [[texture(${e})]]`,o+=`, sampler u_inputTex${e}Smplr [[sampler(${e})]]`,s+=`
              float4 input${e} = u_inputTex${e}.sample(u_inputTex${e}Smplr, in.uv);
            `;return`
#pragma clang diagnostic ignored "-Wmissing-prototypes"

#include <metal_stdlib>
#include <simd/simd.h>

using namespace metal;

struct main0_out
{
    float4 gl_FragColor [[color(0)]];
};

struct main0_in
{
    float2 uv;
};

${n}

fragment main0_out main0(main0_in in [[stage_in]]${r}${o})
{
    main0_out out = {};
    float4 result = float4(1.0, 0.0, 1.0, 1.0);
    ${s};
    ${e};
    out.gl_FragColor = result;
    return out;
}
        `.replace(/;[\s\r\n]*;/gm,";")}case"conv.fs":{const{core:e}=t,a=5;let n=``;for(const t of e)n+=`
              result += (u_inputTex.sample(u_inputTexSmplr, (in.uv + float2(${t[0].toFixed(a)} * invWidth, ${t[1].toFixed(a)} * invHeight))) * ${t[2].toFixed(a)});
              `;return`
          #include <metal_stdlib>
          #include <simd/simd.h>
          
          using namespace metal;
          
          /* struct buffer_t */
          /* { */
          /*     float invWidth; */
          /*     float invHeight; */
          /* }; */
          
          struct main0_out
          {
              float4 gl_FragColor [[color(0)]];
          };
          
          struct main0_in
          {
              float2 uv;
          };
          
          fragment main0_out main0(main0_in in [[stage_in]], texture2d<float> u_inputTex [[texture(0)]], sampler u_inputTexSmplr [[sampler(0)]], constant float& invWidth [[buffer(0)]], constant float& invHeight [[buffer(1)]])
          {
              main0_out out = {};
              float4 result = float4(0.0);
              ${n}
              out.gl_FragColor = result;
              return out;
          }
          `}case"blur.fs":return``;default:return console.log(`Cannot find shader [${e}]!`),"";}}static get(e,t=void 0){switch(e){case"common.vs":return`

attribute vec3 inPosition;
attribute vec2 inTexCoord;
varying vec2 uv;
void main() {
    gl_Position = vec4(inPosition, 1.0);
    uv = inTexCoord;
}
        `;case"mask.fs":return`
precision highp float;
varying vec2 uv;
uniform sampler2D u_maskTex;
uniform sampler2D u_inputTex;
uniform int uFlipY;
uniform int uMaskFlipY;
uniform float uMaskThreshold;

void main() {
    vec2 uv1 = uv;
    if (uMaskFlipY > 0) {
        uv1.y = 1.0 - uv1.y;
    }

    vec2 uv2 = uv;
    if (uFlipY > 0) {
        uv2.y = 1.0 - uv2.y;
    }
    
    vec3 texDest = texture2D(u_inputTex, uv2).rgb;
    float texMask = texture2D(u_maskTex, uv1).r;
    gl_FragColor = vec4(
        texDest,
        clamp(texMask, 0.0, 1.0)
    );
}
        `;case"laplacian.fs":{const{hammersleyNumSample:e}=t;return`
    precision highp float;
    uniform sampler2D uDestinationTexture;
    uniform sampler2D uPrevPassTexture;
    uniform sampler2D uPrevLvlPassTexture;
    uniform float uIteration;
    uniform float uLevel;
    uniform vec2 uBlurScale;
    uniform float uMaskThreshold;
    uniform vec2 uDestTextureSize;
    uniform vec2 u_hammersley[${0|e}];

    varying vec2 uv;

    const float kTriangleKernelSum = 20.0;
    const float kTriangleKernelSize = 4.0;
    const float EPSILON = 0.0001;

    // https://www.shadertoy.com/view/4djSRW
    // TODO: SLOW!
    vec2 hash22(vec2 p) {
        vec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));
        p3 += dot(p3, p3.yzx+33.33);
        return fract((p3.xx+p3.yz)*p3.zy);
    }


    void main() {
        vec4 outColor = texture2D(uDestinationTexture, uv);

        if (outColor.a > uMaskThreshold) {

            // Mutiply by 1000.0 for better hash distribution.
            vec2 rnd = hash22(1000.0*uv);
            vec2 texDestSize = uDestTextureSize;
            float minSide = min(texDestSize.x, texDestSize.y);

            if (uIteration < EPSILON && uLevel < EPSILON) {
                vec2 ratio = texDestSize / vec2(minSide);
                float rangeStep = 0.1;
                float range = 0.02;
                float weightSum = 0.0;
                vec3 sum = vec3(0.0);

                for (int j = 0; j < ${0|e}; ++j) {
                    weightSum = 0.0;
                    sum = vec3(0.0);

                    for (int i = 0; i < ${0|e}; ++i) {
                        // Multiply by ratio to compensate for the difference
                        // between pyramid and dest resolution difference.
                        vec2 hUv = ratio * u_hammersley[i];
                        vec2 sUv = uv + range * (fract(hUv + rnd) - 0.5);
                        if (sUv.x < 0.0 || sUv.x > 1.0
                            || sUv.y < 0.0 || sUv.y > 1.0) {
                            continue;
                        }
                        vec4 rndTex = texture2D(uDestinationTexture, sUv);
                        if (rndTex.a < uMaskThreshold) {
                            sum += rndTex.rgb;
                            weightSum += 1.0;
                        }
                    }

                    if (weightSum > 0.5) {
                        break;
                    }

                    range += rangeStep;
                }

                outColor = vec4(sum/weightSum, 1.0);
            }
            else if (uIteration < EPSILON && uLevel > EPSILON) {
                outColor = texture2D(uPrevLvlPassTexture, uv);
            }
            else {
                vec2 ratioRcp = vec2(minSide) / texDestSize;
                vec3 ret = vec3(0.0);
                float size = kTriangleKernelSize;
                for (float i = -size; i <= size; ++i) {
                    if (abs(i) < 0.5)
                        continue;

                    // Mutiliply sample uv by ratioRcp to compensate for the difference
                    // between pyramid and dest resolution difference.
                    vec4 smpl = texture2D(uPrevPassTexture, uv + i * uBlurScale * ratioRcp);
                    float weight = (size + 1.0 - abs(i)) / kTriangleKernelSum;
                    ret += weight * smpl.rgb;
                }

                outColor = vec4(ret, 1.0);
                // Add random value to compensate for banding due to low texture precission
                outColor.rgb += (rnd.r + rnd.g - 1.0) / 255.0 / kTriangleKernelSum;
            }
        }
        gl_FragColor = outColor;
    }    
        `}case"resolve.fs":return`
    uniform sampler2D uTopLevelTexture;
    uniform sampler2D u_maskTex;
    uniform float uMaskThreshold;

    uniform int uFlipY;
    uniform int uMaskFlipY;

    varying vec2 uv;

    void main()
    {
        vec2 uv1 = uv;
        if (uMaskFlipY > 0) {
            uv1.y = 1.0 - uv1.y;
        }

        vec4 tex = texture2D(uTopLevelTexture, uv);
        float mask = texture2D(u_maskTex, uv1).r;
        if(mask < uMaskThreshold) {
            discard;
        }
        float alpha = (tex.a - uMaskThreshold) / (1.0 - uMaskThreshold);
        tex.a = clamp(alpha, 0.0, 1.0);
        gl_FragColor = tex;
    }
        `;case"grow.fs":{let e="";for(let t=-1;1>=t;++t)for(let a=-1;1>=a;++a)e+=`

                        if(texture2D(maskTexture, uv + u_texelSize*vec2(${0|t}, ${0|a}) )[u_channelIndex] > u_threshold) {
                            gl_FragColor = vec4(1.0);
                            return;
                        }

                        `;return`
precision lowp float;
precision lowp sampler2D;
uniform sampler2D maskTexture;
uniform vec2 u_texelSize;
uniform float u_threshold;
uniform int u_channelIndex;
varying vec2 uv;
void main()
{
    /* if (u_flipY > 0) { */
    /*     uv.y = 1.0 - uv.y; */
    /* } */
    ${e}
    gl_FragColor = vec4(0.0);
}
                `}case"operator.fs":{const{snippet:e,operandNum:a,decl:n}=t;let r="",o="";for(let e=0;e<a;++e)r+=`
            uniform sampler2D u_inputTex${e};
            `,o+=`
                vec4 input${e} = texture2D(u_inputTex${e}, uv);
            `;return`
precision lowp float;
precision lowp sampler2D;
${r};
varying vec2 uv;

${n}

void main()
{
    vec4 result = vec4(1.0, 0.0, 1.0, 1.0); // purple screen
    ${o};
    ${e};
    gl_FragColor = result;
}
        `.replace(/;[\s\r\n]*;/gm,";")}case"conv.fs":{const{core:e}=t,a=5;let n=``;for(const t of e)n+=`
              result += ${t[2].toFixed(a)}*texture2D(u_inputTex, uv + vec2((${t[0].toFixed(a)})*invWidth, (${t[1].toFixed(a)})*invHeight));
              `;return`
precision lowp float;
precision lowp sampler2D;
varying vec2 uv;
uniform sampler2D u_inputTex;
uniform float invWidth;
uniform float invHeight;
void main()
{
    vec4 result = vec4(0.0);
    ${n};
    gl_FragColor = result;
}
          `}case"blur.fs":return``;default:return console.log(`Cannot find shader [${e}]!`),"";}}}class St extends ft{constructor(e,t){super(e,t);const a=this.getProp("operandNum")?this.getProp("operandNum"):1,n=this.getProp("snippet")||"vec4 result = input0",i=!!this.getProp("blend"),r=this.getProp("decl")?this.getProp("decl"):"";for(;this.inputSize<a;)this.addInput(void 0);const o=this.getProp("vs")?this.getProp("vs"):Tt.get("common.vs"),s=Tt.get("operator.fs",{operandNum:a,snippet:n,decl:r}),d=Tt.getMetal("common.vs"),l=Tt.getMetal("operator.fs",{operandNum:a,snippetMetal:this.getProp("snippetMetal")?this.getProp("snippetMetal"):this.toMetal(n),declMetal:this.getProp("declMetal")?this.getProp("declMetal"):this.toMetal(r)});this._opMat=Be.createEmptyMaterial(),Be.addPassToMaterial(this._opMat,{gles2:{vs:o,fs:s},metal:{vs:d,fs:l}},!1,i)}get material(){return this._opMat}toMetal(e){return e=e.replace(/(vec)([1234]+)/gm,"float$2"),e=e.replace(/(mat)([1234])/gm,"float$2x$2"),e=e.replace(/(texture2D)\((.*),(.*)\)/gm,"$2.sample($2Smplr, $3)"),e}onUpdate(e,t){if(this.needUpdateTexture)if(this.isInputsReady()&&this.isOutputsReady()){for(let e=0;e<this.inputSize;++e)this._opMat.setTex(`u_inputTex${e}`,this.getInput(e));t.blitWithMaterial(this.getInput(0),this.getOutput(0),this._opMat,0),this.needUpdateTexture=!1}else console.warn(`[JS GPUFilter] OperatorFilter[${this.name}] cannot get inputs or output ready, check if your link is correct!`)}static predefinedOperators(e,t){return`OP_ADD`===t?new St(e,{operandNum:2,snippet:`
                result = input0 + input1;
                `}):`OP_BLEND`===t?new St(e,{operandNum:2,snippet:`
                // base input0
                result.rgb = mix(input0.rgb, input1.rgb, input0.a);
                result.a = 1.0;
                `}):`OP_MUL`===t?new St(e,{operandNum:2,snippet:`
                // base input0
                result.rgb = input0.rgb*input1.rgb;
                result.a = 1.0;
                `}):new St(e,{operandNum:1,snippet:`
                // base input0
                result.rgb = input0;
                result.a = 1.0;
                `})}}class Ct extends ft{constructor(e,t){super(e,t);const a=!!this.getProp("blend");this.getProp("iterations")===void 0&&this.setProp("iterations",2);const n=this.getProp("vs")?this.getProp("vs"):Tt.get("common.vs"),i=this.getProp("fs"),r=this.getProp("vsMetal")?this.getProp("vsMetal"):Tt.getMetal("common.vs"),o=this.getProp("fsMetal");this._pingpongMat=Be.createEmptyMaterial(),Be.addPassToMaterial(this._pingpongMat,{gles2:{vs:n,fs:i},metal:{vs:r,fs:o}},!1,a)}handleMaterialProp(){}onUpdate(e,a,n){if(this.needUpdateTexture)if(this.isReady()){const e=this.getInput(0).width,r=this.getInput(0).height;(0===e||0===r)&&console.error(`[JS GPUFilter] Pingpong Filter [${this.name}] width/height not correct!`);const o=i.RGBA8Unorm,s=n.get(e,r,o,exports.TextureFilterMode.Linear),d=this.getProp("iterations");let l=this.getInput(0),c=this.getOutput(0);for(let e=0;e<d;++e){const n=new t.MaterialPropertyBlock;if(n.setTexture("u_inputTex",l),n.setFloat("invWidth",1/l.width),n.setFloat("invHeight",1/l.height),this.handleMaterialProp(n),a.blitWithMaterialAndProperties(l,c,this._pingpongMat,0,n),0==e)l=this.getOutput(0),c=s;else{const e=l;l=c,c=e}}l!==this.getOutput(0)&&a.blit(l,this.getOutput(0)),n.return(s),this.needUpdateTexture=!1}else console.warn(`[JS GPUFilter] Pingpong Filter [${this.name}] cannot get inputs or output ready, check if your link is correct!`)}}class It extends Ct{constructor(e,t){const{core:a,iterations:n,blend:i}=t,r=Tt.get("conv.fs",{core:a||[[0,0,1]]}),o=Tt.getMetal("conv.fs",{core:a||[[0,0,1]]});super(e,{iterations:n,fs:r,fsMetal:o,blend:i})}}function xt(){return xt=Object.assign||function(e){for(var t=1,a;t<arguments.length;t++)for(var n in a=arguments[t],a)Object.prototype.hasOwnProperty.call(a,n)&&(e[n]=a[n]);return e},xt.apply(this,arguments)}const Pt=new Uint32Array(1);function Mt(e){return Pt[0]=e,Pt[0]=(Pt[0]<<16|Pt[0]>>16)>>>0,Pt[0]=(1431655765&Pt[0])<<1|(2863311530&Pt[0])>>>1>>>0,Pt[0]=(858993459&Pt[0])<<2|(3435973836&Pt[0])>>>2>>>0,Pt[0]=(252645135&Pt[0])<<4|(4042322160&Pt[0])>>>4>>>0,Pt[0]=(16711935&Pt[0])<<8|(4278255360&Pt[0])>>>8>>>0,23283064365386963e-26*Pt[0]}function Rt(e,a){return new t.Vector2f(e/a,Mt(e))}class Ft extends ft{constructor(e,a){super(e,xt({},{quality:"low",blendEnable:!0,maskFlip:!0,inputFlip:!0,maskThreshold:.5},a)),this._pingpongPyramids=new t.Vector,this.addInput(void 0);const{numOfSamples:n,pyramidIterations:r,pyramidTopSize:o}=Ft.PREDEFINED[this.getProp("quality")],s=Tt.get("common.vs"),d=Tt.getMetal("common.vs"),l=Tt.get("mask.fs"),c=Tt.getMetal("mask.fs"),p=n,u=Tt.get("laplacian.fs",{hammersleyNumSample:p}),m=Tt.getMetal("laplacian.fs",{hammersleyNumSample:p}),g=Tt.get("resolve.fs"),_=Tt.getMetal("resolve.fs"),f=i.RGBA8Unorm;this._inpaintMat=Be.createEmptyMaterial(),Be.addPassToMaterial(this._inpaintMat,{gles2:{vs:s,fs:l},metal:{vs:d,fs:c}},!1),Be.addPassToMaterial(this._inpaintMat,{gles2:{vs:s,fs:u},metal:{vs:d,fs:m}},!1),Be.addPassToMaterial(this._inpaintMat,{gles2:{vs:s,fs:g},metal:{vs:d,fs:_}},!1,this.getProp("blendEnable")),this._hammersleySamples=new t.Vec2Vector,this._pingpongPyramids.pushBack(this.buildPyramid(o,r.length,f,exports.TextureFilterMode.Nearest)),this._pingpongPyramids.pushBack(this.buildPyramid(o,r.length,f,exports.TextureFilterMode.Nearest));for(let t=0;t<p;++t)this._hammersleySamples.pushBack(Rt(t,p))}buildPyramid(e,a,n,r){const o=new t.Vector;for(let t=0;t<a;++t){const a=e<<t;o.pushBack(Be.createRenderTexturePlus(a,a,n,r))}return o}onUpdate(e,t){this.needUpdateTexture&&(this.isInputsReady()&&this.isOutputsReady()?(this.buildCmd(t),this.needUpdateTexture=!1):console.warn(`[JS GPUFilter] OperatorFilter[${this.name}] cannot get inputs or output ready, check if your link is correct!`))}buildCmd(e){const a=this.getInput(0),n=this.getInput(1),r=this.getOutput(0);if(this._inpaintMat.setTex("u_inputTex",a),this._inpaintMat.setTex("u_maskTex",n),this._inpaintMat.setInt("uMaskFlipY",this.getProp("maskFlip")?1:0),this._inpaintMat.setInt("uFlipY",this.getProp("inputFlip")?1:0),this._inpaintMat.setFloat("uMaskThreshold",this.getProp("maskThreshold")),e.blitWithMaterial(a,r,this._inpaintMat,0),this._inpaintMat.setTex("uDestinationTexture",r),this._inpaintMat.setVec2("uDestTextureSize",new t.Vector2f(r.width,r.height)),!this._pingpongPyramids.empty()){const{pyramidIterations:a}=Ft.PREDEFINED[this.getProp("quality")],n=a.length;let o=this._pingpongPyramids.get(0),s=this._pingpongPyramids.get(1),d=r;for(let c=0;c<n;++c){const n=0==c?r:o.get(c-1);for(let d=0;d<a[c];++d){const a=o.get(c),i=s.get(c),l=new t.MaterialPropertyBlock;l.setVec2Vector("u_hammersley",this._hammersleySamples),l.setTexture("uPrevPassTexture",a),l.setTexture("uPrevLvlPassTexture",n),l.setFloat("uIteration",d),l.setFloat("uLevel",c);const p=0==d%2?1/a.width:0,u=1==d%2?1/a.height:0,m=new t.Vec2Vector;m.pushBack(new t.Vector2f(p,u)),l.setVec2Vector("uBlurScale",m),e.blitWithMaterialAndProperties(r,i,this._inpaintMat,1,l);const g=s;s=o,o=g}const i=o.get(c);d=i}this._inpaintMat.setTex("uTopLevelTexture",d),e.blitWithMaterial(d,r,this._inpaintMat,2)}}}Ft.PREDEFINED={low:{numOfSamples:16,pyramidIterations:[5,5,3],pyramidTopSize:32},medium:{numOfSamples:32,pyramidIterations:[5,11,5,3],pyramidTopSize:64},high:{numOfSamples:64,pyramidIterations:[5,11,11,5,5],pyramidTopSize:64}};class At extends ft{constructor(e,t){super(e,t),this._quadMat=this.getProp("material")?this.getProp("material"):Be.createEmptyMaterial(),this._updater=this.getProp("updater")?this.getProp("updater"):()=>{}}onUpdate(e,t){if(this.needUpdateTexture)if(this.isReady()){this._updater(this._quadMat);const e=this.getInput(0),a=this.getOutput(0);t.blitWithMaterial(e,a,this._quadMat,0),this.needUpdateTexture=!1}else console.warn(`[JS GPUFilter] Material Filter [${this.name}] cannot get inputs or output ready, check if your link is correct!`)}getOutRTInfo(e=0,t){var a=Math.floor;const n=super.getOutRTInfo(e,t),i=this.getProp("widthScalar")?this.getProp("widthScalar"):1,r=this.getProp("heightScalar")?this.getProp("heightScalar"):1;return n.width=a(n.width*i),n.height=a(n.height*r),n}}class Et extends ft{constructor(e,t){super(e,xt({},{threshold:.5,channel:"red",growAmount:5},t));const a=Tt.get("common.vs"),n=Tt.get("grow.fs"),i=Tt.getMetal("common.vs"),r=Tt.getMetal("grow.fs");this._growMat=Be.createEmptyMaterial(),Be.addPassToMaterial(this._growMat,{gles2:{vs:a,fs:n},metal:{vs:i,fs:r}},!1)}buildCmd(e,a){const n=this.getInput(0),i=this.getOutput(0),r=this.getProp("channel");let o=this.getProp("growAmount");o=Math.min(Et.MAX_GROW_ITERATION,o);const s=this.getProp("threshold"),d=1/i.width,l=1/i.height,c=Et.CHANNEL_MAP.get(r)||0;this._growMat.setInt("u_channelIndex",c),this._growMat.setVec2("u_texelSize",new t.Vector2f(d,l)),this._growMat.setFloat("u_threshold",s),e.blit(n,i);let p=i;const u=a.get(i.width,i.height,i.colorFormat,i.filterMag);let m=u,g=p;for(let n=0;n<o;++n){const a=new t.MaterialPropertyBlock;a.setTexture("maskTexture",p),e.blitWithMaterialAndProperties(p,m,this._growMat,0,a);const n=m;m=p,p=n,g=p}a.return(u),g!==i&&e.blit(g,i)}onUpdate(e,t,a){this.needUpdateTexture&&(this.isInputsReady()&&this.isOutputsReady()?(this.buildCmd(t,a),this.needUpdateTexture=!1):console.warn(`[JS GPUFilter] OperatorFilter[${this.name}] cannot get inputs or output ready, check if your link is correct!`))}}Et.MAX_GROW_ITERATION=32,Et.CHANNEL_MAP=new Map([["red",0],["green",1],["blue",2],["alpha",3]]);const kt="internal_blit",Lt="BlitFilter",Nt="OperatorFilter",bt="PingpongFilter",Dt="MaterialFilter",Bt="InpaintFilter",wt="GrowFilter",Ot="ConvFilter";class zt{static makeFilter(e){const t=e.class,a=e.name;switch(t){case Lt:return new vt(a,e.properties);case Nt:return new St(a,e.properties);case bt:return new Ct(a,e.properties);case Ot:return new It(a,e.properties);case Dt:return new At(a,e.properties);case Bt:return new Ft(a,e.properties);case wt:return new Et(a,e.properties);default:const n=St.predefinedOperators(a,t);return n;}}}var Vt=t.CommandBuffer,Ht=t.Texture;class Ut{constructor(e,t){if(this.from=void 0,this.fromIndex=0,this.to=void 0,this.toIndex=0,this._filterGraph=t,this.deserialize(e),void 0===this.to&&void 0===this.from)throw new Error(`[JS GPUFilter] Invalid filter node linking`)}unlink(){this.from&&this.from.setOutput(void 0,this.fromIndex),this.to&&this.to.setInput(void 0,this.toIndex)}serialize(){return{from:this.from?this.from.name:void 0,fromIndex:this.fromIndex,to:this.to?this.to.name:void 0,toIndex:this.toIndex}}getKey(){return JSON.stringify(this.serialize())}static getKeyFrom(e,t,a,n){return JSON.stringify({from:e,fromIndex:t,to:a,toIndex:n})}deserialize(e){this.from=this._filterGraph.getFilter(e.from)||void 0,this.to=this._filterGraph.getFilter(e.to)||void 0,this.fromIndex=e.fromIndex,this.toIndex=e.toIndex}}class Gt{constructor(e,t=void 0){this.filter=e,this.hook=t}}class Wt{constructor(){this.camera=void 0,this.cameraRenderEvent=exports.CameraRenderEvent.AfterRender,this.cameraCallback=()=>{}}clear(){this.camera=void 0,this.cameraRenderEvent=exports.CameraRenderEvent.AfterRender,this.cameraCallback=()=>{}}isBound(){return this.camera!==void 0}}const qt=32;class Yt{constructor(){this._inputs=[void 0],this._outputs=[void 0],this._orderedFilters=[],this._filters=new Map,this._links=new Map,this._sorted=!1,this._cmdBufferQueue=[],this._currentCmdBufferIndex=0,this._texturePool=new yt(qt),this._linkTexturePool=new yt(qt),this._cameraInfo=new Wt,this._debug=!1,this._running=!0}init(){}clear(){this.clearTexture(),this._orderedFilters.length=0,this._links.clear(),this._filters.clear(),this.commandBuffer.clearAll(),this._texturePool.clearAll(),this._linkTexturePool.clearAll()}get inputSize(){return this._inputs.length}get outputSize(){return this._outputs.length}getInput(e){return this._inputs[e]}getOutput(e){return this._outputs[e]}setInput(e,t){this._inputs[t]=e}setOutput(e,t){this._outputs[t]=e}clearTexture(){this._inputs.length=0,this._outputs.length=0}deserialize(e,t){this.clear();for(const a of e.nodes){const e=t(a);this._orderedFilters.push(e),this.addFilter(a.name,e,!1)}for(const a of e.links){const e=new Ut(a,this);this._links.set(e.getKey(),e)}}serialize(){const e=[];this._links.forEach(t=>{e.push(t.serialize())});const t=[];for(const e of this._orderedFilters)t.push(e.serialize());return{links:e,nodes:t}}render(){if(!this._running)return;let e=0;for(const t in this._orderedFilters){const a=this._orderedFilters[t];if(a.render(),this._debug){const n=this._filters.get(a.name).hook;this._commitCommandBuffer(e++),void 0!==n&&n(t,a)}}this._commitCommandBuffer(e)}_commitCommandBuffer(e){Ua.engine&&(e<this._cmdBufferQueue.length?Ua.engine.scene.native.commitCommandBuffer(this._cmdBufferQueue[e]):console.warn(`[JS GPUFilter] command buffer index out of boundary! Render failed!`))}set debug(e){this._debug=e}get debug(){return this._debug}get commandBuffer(){return 0===this._cmdBufferQueue.length&&this.addCmdBuffer(),this._cmdBufferQueue[this._currentCmdBufferIndex]}addCmdBuffer(){this._cmdBufferQueue.push(new Vt),this._currentCmdBufferIndex=this._cmdBufferQueue.length-1}bind(e,a,n=[],i=void 0,r=!1){this._cameraInfo.isBound()&&this.unbind(),this._cameraInfo.camera=e,this._cameraInfo.cameraRenderEvent=a,this._cameraInfo.cameraCallback=()=>{this.render()},t.AmazingManager.addListener(this._cameraInfo.camera.native,this._cameraInfo.cameraRenderEvent,this._cameraInfo.cameraCallback,void 0),this._inputs[0]=i instanceof Ht?i:e.renderTexture,this._outputs[0]=e.renderTexture;for(const t of n)this._inputs.push(t);if(!r){const e=zt.makeFilter({class:Lt,name:kt});e?(this.add(e),console.info("[JS Filter] internal_blit filter was created to avoid read/write the same render target. Please use internal_blit.inputs[0] as the systems inputs[0]!!!")):console.warn("[JS Filter] Failed to create internal_blit filter as requested in the options.")}}onEnable(){this._running=!0}onDisable(){this._running=!1}unbind(e=!0){var a;t.AmazingManager.removeListener(null==(a=this._cameraInfo.camera)?void 0:a.native,this._cameraInfo.cameraRenderEvent,this._cameraInfo.cameraCallback,void 0),this._cameraInfo.clear(),e&&this.clear()}_autolink(e,t,a){var n=Math.min;const r=e?e.outputSize:this._inputs.length,o=a?a.inputSize:this._outputs.length;for(let o=0;o<n(r,t.inputSize);++o)this.link(e?e.name:void 0,o,t.name,o);for(let r=0;r<n(o,t.inputSize);++r)this.link(t.name,r,a?a.name:void 0,r)}addFilter(e,t,a=!0){if(this.removeFilter(e),this._filters.set(e,new Gt(t)),this._sorted=!1,a)if(0>=this._orderedFilters.length)this._autolink(void 0,t,void 0);else{const e=this._orderedFilters[this._orderedFilters.length-1];for(let t=0;t<e.outputSize;++t){const a=Ut.getKeyFrom(e.name,t,void 0,t);e.setOutput(void 0,t),this._links.delete(a)}this._autolink(e,t,void 0)}}add(e,t=!0){e instanceof ft?this.addFilter(e.name,e,t):this.addFilter(e.name,zt.makeFilter(e),t)}getFilter(e){var t;return null==(t=this._filters.get(e))?void 0:t.filter}removeFilter(e){const t=this.getFilter(e);if(t){for(const e of this._links.keys()){const a=this._links.get(e);if(a.from===t||a.to===t){if(this._links.delete(e),void 0===a.from||void 0===a.to)continue;const n=a.from===t?a.toIndex:a.fromIndex;a.from===t?a.to.setInput(void 0,n):a.from.setOutput(void 0,n)}}this._filters.delete(t.name),this.topsort(),this.optimizeRT()}}link(e,t,a,n){const i=new Ut({from:e,to:a,fromIndex:t,toIndex:n},this);this._links.has(i.getKey())||this._links.set(i.getKey(),i),this.graphChanged()}graphChanged(){this.topsort(),this.optimizeRT()}unlink(e,t,a,n){const i=new Ut({from:e,to:a,fromIndex:t,toIndex:n},this);this._links.has(i.getKey())&&(this._links.delete(i.getKey()),i.unlink(),this.graphChanged())}topsort(){const e={};this._links.forEach(t=>{t.from&&t.to&&(!e[t.from.name]&&(e[t.from.name]=new Set),e[t.from.name].add(t.to.name))}),this._orderedFilters.length=0;const t=new Map;this._filters.forEach((a,n)=>{if(!this._topsort(n,e,t,this._orderedFilters))throw new Error(`[JS GPUFilter] Cannot sort filter, and system will not sort it again but give up :(!`)}),this._orderedFilters.reverse(),this._sorted=!0}optimizeRT(){if(!this._sorted)return;this._linkTexturePool.returnAll();const e={},t={};this._links.forEach(t=>{t.from!==void 0&&(!e.hasOwnProperty(t.from.name)&&(e[t.from.name]={in:[],out:[]}),e[t.from.name].out.push(t)),t.to!==void 0&&(!e.hasOwnProperty(t.to.name)&&(e[t.to.name]={in:[],out:[]}),e[t.to.name].in.push(t))});const a=e=>`${void 0===e.from?void 0:e.from.name}.${e.fromIndex}`;for(const n in this._orderedFilters){const i=this._orderedFilters[n],r=e[i.name]?e[i.name].in:[];for(const e of r)if(e.from!==void 0){const i=a(e);t.hasOwnProperty(i)||(t[i]=+n),t[i]=Math.max(t[i],+n)}i.clear()}for(const n in this._orderedFilters){const i=this._orderedFilters[n],r=e[i.name]?e[i.name].out:[];for(const e of r)this.populateTextureSlots(e);const o=e[i.name]?e[i.name].in:[];for(const e of o)if(e.from!==void 0){const i=a(e);t[i]<=+n&&this._linkTexturePool.return(e.from.getOutput(e.fromIndex))}else this.populateTextureSlots(e)}}populateTextureSlots(e){const t=e.fromIndex,a=e.toIndex;let n,i;n=e.from?e.from.getOutput(t):this.getInput(t),i=e.to?e.to.getInput(a):this.getOutput(a);let r;if(void 0===n&&void 0===i){if(void 0===e.from)return new Error("Invalid from-filter-node in filter link.");const a=e.from.getOutRTInfo(t,this._inputs[0]);if(r=this._linkTexturePool.get(a.width,a.height,a.colorFormat,a.filterMode),r instanceof Error)return r}if(void 0===n){var o;const a=null==(o=i)?r:o;e.from?e.from.setOutput(a,t):this.setInput(a,t)}if(void 0===i){var s;const t=null==(s=n)?r:s;e.to?e.to.setInput(t,a):this.setOutput(t,a)}e.to&&(e.to.needUpdateTexture=!0),e.from&&(e.from.needUpdateTexture=!0)}_topsort(e,t,a,n){if(a.has(e)&&1===a.get(e))return!0;if(a.has(e)&&0===a.get(e))return!1;if(a.set(e,0),t[e])for(const i of t[e])if(!this._topsort(i,t,a,n))return!1;return n.push(this._filters.get(e).filter),a.set(e,1),!0}setHook(e,t){this._filters.get(e).hook=t}onUpdate(e){if(!this._running)return;let t=!1;this._sorted||(console.warn(`[JS GPUFilter] Och, have to sort filter because you forgot to do that!`),this.topsort(),this.optimizeRT(),t=!0);for(const a of this._orderedFilters)if(a.needUpdateTexture){t=!0,this.clearCommandBuffer();break}for(const a of this._orderedFilters){if(t&&(a.needUpdateTexture=!0),a.onUpdate(e,this.commandBuffer,this._texturePool),this._debug){const e=this._filters.get(a.name).hook;void 0!==e&&this.addCmdBuffer()}this._texturePool.returnAll()}}clearCommandBuffer(){for(const e of this._cmdBufferQueue)e.clearAll();this._currentCmdBufferIndex=0}toString(){return JSON.stringify(this.serialize())}}class jt{constructor(){this._filterGraphs=new Map}static getInstance(){return null==this._instance&&(this._instance=new jt),this._instance}static create(e){const t=this.getInstance();if(t._filterGraphs.has(e))return new Error("Cannot create duplicated graph name.");if(""===e)return new Error("Cannot create empty name graph.");else{const a=new Yt;return t._filterGraphs.set(e,a),a}}static remove(e){const t=this.getInstance();let a="";if(e instanceof Yt){for(const[n,i]of t._filterGraphs)if(i===e){a=n;break}}else a=e;if(t._filterGraphs.has(a)){const e=t._filterGraphs.get(a);null==e?void 0:e.clear(),t._filterGraphs.delete(a)}else return new Error("Cannot find target graph in the system!")}static get(e){const t=this.getInstance();return t._filterGraphs.has(e)?t._filterGraphs.get(e):new Error("Cannot find target graph!")}static get size(){const e=this.getInstance();return e._filterGraphs.size}init(){for(const e of this._filterGraphs.values())e.init()}onUpdate(e){for(const t of this._filterGraphs.values())t.onUpdate(e)}}class Kt extends e{constructor(){super(),this.hands=[],this._handProvider=new Qt(this)}static getInstance(){return null==this._instance&&(this._instance=new Kt),this._instance}static get hands(){return this.getInstance().hands}static on(e,t,a){return this.getInstance().on(e,t,a)}static off(e,t,a){return this.getInstance().off(e,t,a)}onUpdate(){this._handProvider.onUpdate()}init(){}setHandState(e,t){e?this.fire(exports.HandEvent.Detected,t):this.fire(exports.HandEvent.Lost,t)}setHandActionState(e,t){t!==exports.HandStaticGesture.None&&t!==exports.HandStaticGesture.Unknown&&this.fire(exports.HandEvent.StaticGesture,e,t)}setHandSeqActionState(e,t){t!==exports.HandDynamicGesture.None&&this.fire(exports.HandEvent.DynamicGesture,e,t)}}class Xt{constructor(){this._handInfo=null}getKeyPoint2D(e){return 1===this._handInfo.key_points_is_detect.get(e)?this._handInfo.key_points_xy.get(e):null}getKeyPointOffset3D(e){return 1===this._handInfo.key_points_3d_is_detect.get(e)?this._handInfo.key_points_3d.get(e):null}get isLeftProbability(){return this._handInfo.left_prob}get isLeft(){return!(.5>this.isLeftProbability)}get id(){return this._handInfo.ID}get scale(){return this._handInfo.scale}get rotation(){const e=this.getKeyPoint2D(9),t=this.getKeyPoint2D(12);if(null==t||null==e)return 0;const a=t.x-e.x,n=t.y-e.y,i=Math.sqrt(a*a+n*n);return 180*(-a/Math.abs(a)*Math.acos(n/i))/Math.PI}get staticGesture(){return this._handInfo.action}get dynamicGesture(){return this._handInfo.seq_action}}class Qt{constructor(e){this._mgr=e,this.lastHandIdSet=new Set,this.ActIDMap=new Map,this.SeqActIDMap=new Map}onUpdate(){var e;const t=null==(e=Ua.engine)?void 0:e.algoritms.nativeResult,a=t.getHandCount();this._mgr.hands=Array(a);const n=new Set;if(0<a){for(let e=0;e<a;e++){const a=t.getHandInfo(e),i=new Xt;this._mgr.hands[e]=i,null!=a&&(i._handInfo=a,!this.lastHandIdSet.has(i.id)&&this._mgr.setHandState(!0,i.id),this.ActIDMap.has(i.id)?this.ActIDMap.get(i.id)!==i.staticGesture&&(this._mgr.setHandActionState(i.id,i.staticGesture),this.ActIDMap.set(i.id,i.staticGesture)):(this.ActIDMap.set(i.id,i.staticGesture),this._mgr.setHandActionState(i.id,i.staticGesture)),this.SeqActIDMap.has(i.id)?this.SeqActIDMap.get(i.id)!==i.dynamicGesture&&(this._mgr.setHandSeqActionState(i.id,i.dynamicGesture),this.SeqActIDMap.set(i.id,i.dynamicGesture)):(this.SeqActIDMap.set(i.id,i.dynamicGesture),this._mgr.setHandSeqActionState(i.id,i.dynamicGesture)),n.add(i.id))}for(const e of this.lastHandIdSet.values())n.has(e)||this._mgr.setHandState(!1,e);for(const e of this.ActIDMap.keys())n.has(e)||this.ActIDMap.delete(e);for(const e of this.SeqActIDMap.keys())n.has(e)||this.SeqActIDMap.delete(e);this.lastHandIdSet.clear(),n.forEach(e=>this.lastHandIdSet.add(e))}else{this.ActIDMap.clear(),this.SeqActIDMap.clear();for(const e of this.lastHandIdSet.values())this._mgr.setHandState(!1,e);this.lastHandIdSet.clear()}}}class Jt extends e{constructor(){super(),this.bodies=[],this._body2dProvider=new $t(this)}static getInstance(){return null==this._instance&&(this._instance=new Jt),this._instance}static get bodies(){return this.getInstance().bodies}static on(e,t,a){return this.getInstance().on(e,t,a)}static off(e,t,a){return this.getInstance().off(e,t,a)}onUpdate(){this._body2dProvider.onUpdate()}init(){}setBodyState(e,t){e?this.fire(exports.BodyEvent.Detected,t):this.fire(exports.BodyEvent.Lost,t)}setBodyActionState(e,t){-1!==t&&this.fire(exports.BodyEvent.Action,e,t)}}class Zt{constructor(){this._skeletonInfo=null,this._actionRecognitionInfo=null}get rect(){return this._skeletonInfo.rect}get id(){return this._skeletonInfo.ID}get keyPointDetected(){return this._skeletonInfo.key_points_detected}get keyPointsScore(){return this._skeletonInfo.key_points_score}get keyPoints(){return this._skeletonInfo.key_points_xy}get isActionValid(){return this._actionRecognitionInfo.isValid}get actionLabel(){return this._actionRecognitionInfo.actionLabel}get actionScore(){return this._actionRecognitionInfo.actionScore}}class $t{constructor(e){this._mgr=e,this.lastSkeletonIdSet=new Set,this.ActIDMap=new Map}onUpdate(){var e;const t=null==(e=Ua.engine)?void 0:e.algoritms.nativeResult,a=t.getSkeletonCount();this._mgr.bodies=Array(a);const n=new Set;if(0<a){for(let e=0;e<a;e++){const a=t.getSkeletonInfo(e);let i=null;t.getActionRecognitionInfo&&(i=t.getActionRecognitionInfo(e));const r=new Zt;this._mgr.bodies[e]=r,null!=a&&(r._skeletonInfo=a,!this.lastSkeletonIdSet.has(r.id)&&this._mgr.setBodyState(!0,r.id),null!=i&&(r._actionRecognitionInfo=i,this.ActIDMap.has(r.id)?this.ActIDMap.get(r.id)!==r.actionLabel&&(this._mgr.setBodyActionState(r.id,r.actionLabel),this.ActIDMap.set(r.id,r.actionLabel)):(this.ActIDMap.set(r.id,r.actionLabel),this._mgr.setBodyActionState(r.id,r.actionLabel))),n.add(r.id))}for(const e of this.lastSkeletonIdSet.values())n.has(e)||this._mgr.setBodyState(!1,e);for(const e of this.ActIDMap.keys())n.has(e)||this.ActIDMap.delete(e);this.lastSkeletonIdSet.clear(),n.forEach(e=>this.lastSkeletonIdSet.add(e))}else{this.ActIDMap.clear();for(const e of this.lastSkeletonIdSet.values())this._mgr.setBodyState(!1,e);this.lastSkeletonIdSet.clear()}}}class ea extends e{constructor(){super(),this._trackingMode=!1,this.bodies=[],this._Body3dProvider=new aa(this)}static getInstance(){return null==this._instance&&(this._instance=new ea),this._instance}static get bodies(){return this.getInstance().bodies}static on(e,t,a){return this.getInstance().on(e,t,a)}static off(e,t,a){return this.getInstance().off(e,t,a)}static get trackingMode(){return this.getInstance()._trackingMode}onUpdate(){this._Body3dProvider.onUpdate()}init(){}setBodyState(e,t){e?this.fire(exports.BodyEvent.Detected,t):this.fire(exports.BodyEvent.Lost,t)}}class ta{constructor(){this._avatar3DInfo=null}get id(){return this._avatar3DInfo.tracking_id}get root(){return this._avatar3DInfo.root}get focalLength(){return this._avatar3DInfo.focal_length}get isDetected(){return this._avatar3DInfo.detected}get jointRotations(){return this._avatar3DInfo.quaternion}get jointPositions(){return this._avatar3DInfo.joints}get imageHeight(){return this._avatar3DInfo.imageHeight}get imageWidth(){return this._avatar3DInfo.imageWidth}}class aa{constructor(e){this._mgr=e,this.lastAvatar3dIdSet=new Set}onUpdate(){var e;const t=null==(e=Ua.engine)?void 0:e.algoritms.nativeResult;this._mgr._trackingMode=t.getAvatar3DInfoTracking();const a=t.getAvatar3DInfoCount();this._mgr.bodies=Array(a);const n=new Set;if(0<a){for(let e=0;e<a;e++){const a=t.getAvatar3DInfo(e),i=new ta;this._mgr.bodies[e]=i,null!=a&&(i._avatar3DInfo=a,!this.lastAvatar3dIdSet.has(i.id)&&this._mgr.setBodyState(!0,i.id),n.add(i.id))}for(const e of this.lastAvatar3dIdSet.values())n.has(e)||this._mgr.setBodyState(!1,e);this.lastAvatar3dIdSet.clear(),n.forEach(e=>this.lastAvatar3dIdSet.add(e))}else{for(const e of this.lastAvatar3dIdSet.values())this._mgr.setBodyState(!1,e);this.lastAvatar3dIdSet.clear()}}}class na extends e{constructor(){super(),this.faces=[],this._AvatarDriveProvider=new ra(this)}static getInstance(){return null==this._instance&&(this._instance=new na),this._instance}static get faces(){return this.getInstance().faces}static on(e,t,a){return this.getInstance().on(e,t,a)}static off(e,t,a){return this.getInstance().off(e,t,a)}onUpdate(){this._AvatarDriveProvider.onUpdate()}init(){}setAvatarDriveState(e,t){e?this.fire(exports.AvatarDriveEvent.Detected,t):this.fire(exports.AvatarDriveEvent.Lost,t)}}class ia{constructor(){this._avatarDriveInfo=null}get id(){return this._avatarDriveInfo.ID}get isTracking(){return!(1!==this._avatarDriveInfo.succ)}get channels(){return this._avatarDriveInfo.beta}}class ra{constructor(e){this._mgr=e,this.lastAvatarDriveIdSet=new Set}onUpdate(){var e;const t=null==(e=Ua.engine)?void 0:e.algoritms.nativeResult,a=t.getAvatarDriveCount();this._mgr.faces=Array(a);const n=new Set;if(0<a){for(let e=0;e<a;e++){const a=t.getAvatarDriveInfo(e),i=new ia;this._mgr.faces[e]=i,null!=a&&(i._avatarDriveInfo=a,!this.lastAvatarDriveIdSet.has(i.id)&&this._mgr.setAvatarDriveState(!0,i.id),n.add(i.id))}for(const e of this.lastAvatarDriveIdSet.values())n.has(e)||this._mgr.setAvatarDriveState(!1,e);this.lastAvatarDriveIdSet.clear(),n.forEach(e=>this.lastAvatarDriveIdSet.add(e))}else{for(const e of this.lastAvatarDriveIdSet.values())this._mgr.setAvatarDriveState(!1,e);this.lastAvatarDriveIdSet.clear()}}}class oa{constructor(){this._plugins={}}bufferToStr(e){const t=new Uint8Array(e),a=t.length,n=Array(a);for(let r=0;r<a;r++)n[r]=String.fromCharCode.call(null,t[r]);return n.join("")}start(){for(const e in this.loadPlugins(),this._plugins){const t=this._plugins[e];"function"==typeof t.onStart&&t.onStart()}}loadPlugins(){const e=Ua.engine.scene.native.assetMgr.rootDir,t=e+"js/plugins.json",a=fs.accessSync(t,0);if(a){const e=fs.readFileSync(t);if(null!=e)try{const t=this.bufferToStr(e),a=JSON.parse(t),n=a.plugins;for(const e in n){const t=n[e];this.initPlugin(t,e)}}catch(t){console.error("Failed to load plugins.json"),console.error(t)}}}initPlugin(e,t){if(0>=t.length)return null;const a=be.toPascalCase(t),n=require(a)[a],i=new n;return this._plugins[t]=i,i.init(Ua.engine.scene,e.config),i}update(e){for(const t in this._plugins){const a=this._plugins[t];"function"==typeof a.onUpdate&&a.onUpdate(e)}}lateUpdate(e){for(const t in this._plugins){const a=this._plugins[t];"function"==typeof a.onLateUpdate&&a.onLateUpdate(e)}}destroy(){for(const e in this._plugins){const t=this._plugins[e];"function"==typeof t.onDestroy&&t.onDestroy()}}event(e){for(const t in this._plugins){const a=this._plugins[t];"function"==typeof a.onEvent&&this._plugins[t].onEvent(e)}}get plugins(){return this._plugins}}class sa{constructor(e,t){this.name=e,this.resource=t}}class da{constructor(e){this._engine=e}destroy(){}get rootDir(){return this._engine.scene.native.assetMgr.rootDir}loadSync(e){if(!e.startsWith("share://")&&!e.startsWith("custom://")&&!fs.accessSync(this.rootDir+e,0))return console.error(`Cannot find asset at: ${e}`),null;let a=this._engine.scene.native.assetMgr.SyncLoad(e);if(a){a instanceof t.Material&&(a=new I(a));const n=be.getFilename(e);a=new sa(n,a)}else console.error(`Failed to load: ${e}`);return a}}class la{constructor(){this._nativeAlgoMgr=t.AmazingManager.getSingleton("Algorithm")}get nativeResult(){return this._nativeAlgoResult}update(){this._nativeAlgoResult=this._nativeAlgoMgr.getAEAlgorithmResult()}}class ca extends e{constructor(e,t){super(),this._type=e,this._state=exports.GestureRecognizerState.Possible,this._touchGesture=t}get type(){return this._type}get state(){return this._state}set state(e){this._state=e,(e===exports.GestureRecognizerState.Began||e===exports.GestureRecognizerState.Ended||e===exports.GestureRecognizerState.Changed)&&this._touchGesture.fire(this._type,this)}reset(){}update(){}handleTouch(){}}class pa extends ca{constructor(e){super(exports.GestureType.Tap,e),this._tp1Pos=new t.Vector2f(0,0),this._tp1Time=0,this._touchPos=new t.Vector2f(0,0),this._maxDuration=.5,this._maxDeltaMovement=.02}get position(){return this._touchPos}reset(){this._tp1Pos=new t.Vector2f(0,0),this._tp1Time=0,this._touchPos=new t.Vector2f(0,0)}handleTouch(e){if(this.state!==exports.GestureRecognizerState.Failed){const a=e.type;if(a===t.TouchType.TOUCH_BEGAN)1!==e.count&&(this.state=exports.GestureRecognizerState.Failed),this.state!==exports.GestureRecognizerState.Failed&&(this._tp1Pos=new t.Vector2f(e.x,e.y),this._tp1Time=e.time);else if(a===t.TouchType.TOUCH_MOVED){const a=new t.Vector2f(e.x,e.y),n=this._tp1Pos;(e.time-this._tp1Time>1e6*this._maxDuration||a.distance(n)>this._maxDeltaMovement)&&(this.state=exports.GestureRecognizerState.Failed)}else if(a===t.TouchType.TOUCH_ENDED||a===t.TouchType.TOUCH_CANCELED){const a=new t.Vector2f(e.x,e.y),n=this._tp1Pos;e.time-this._tp1Time<1e6*this._maxDuration&&a.distance(n)<this._maxDeltaMovement?(this._touchPos=a,this.state=exports.GestureRecognizerState.Ended):this.state=exports.GestureRecognizerState.Failed}}}}class ua extends ca{constructor(e){super(exports.GestureType.Pan,e),this._initPos=new t.Vector2f(0,0),this._curPos=new t.Vector2f(0,0)}get initPosition(){return this._initPos}get currentPosition(){return this._curPos}get offset(){const e=this._curPos.copy();return e.sub(this._initPos)}reset(){this._initPos=new t.Vector2f(0,0),this._curPos=new t.Vector2f(0,0)}handleTouch(e){if(this.state!==exports.GestureRecognizerState.Failed){const a=e.type;a===t.TouchType.TOUCH_BEGAN?(1!==e.count&&(this.state=exports.GestureRecognizerState.Failed),this.state!==exports.GestureRecognizerState.Failed&&(this._initPos=new t.Vector2f(e.x,e.y),this.state=exports.GestureRecognizerState.Began)):a===t.TouchType.TOUCH_MOVED?(this.state===exports.GestureRecognizerState.Began||this.state===exports.GestureRecognizerState.Changed)&&(this._curPos=new t.Vector2f(e.x,e.y),this.state=exports.GestureRecognizerState.Changed):(a===t.TouchType.TOUCH_ENDED||a===t.TouchType.TOUCH_CANCELED)&&(this.state===exports.GestureRecognizerState.Changed?this.state=exports.GestureRecognizerState.Ended:this.state=exports.GestureRecognizerState.Failed)}}}class ma extends ca{constructor(e){super(exports.GestureType.Rotation,e),this._tp1Id=99,this._tp1Pos=new t.Vector2f(0,0),this._tp2Id=99,this._tp2Pos=new t.Vector2f(0,0),this._initDir=new t.Vector2f(0,0),this._lastYaw=0,this._deltaYaw=0,this._yaw=0}reset(){this._tp1Id=99,this._tp1Pos=new t.Vector2f(0,0),this._tp2Id=99,this._tp2Pos=new t.Vector2f(0,0),this._initDir=new t.Vector2f(0,0),this._lastYaw=0,this._deltaYaw=0,this._yaw=0}get rotation(){return this._yaw}get delta(){return this._deltaYaw}handleTouch(e){const a=e.type;if(this.state!==exports.GestureRecognizerState.Failed)if(a===t.TouchType.TOUCH_BEGAN){if(2<e.count)return void(this.state=exports.GestureRecognizerState.Failed);99===this._tp1Id?(this._tp1Id=e.pointerId,this._tp1Pos=new t.Vector2f(e.x,e.y)):99!==this._tp1Id&&this._tp1Id!==e.pointerId&&99===this._tp2Id&&(this._tp2Id=e.pointerId,this._tp2Pos=new t.Vector2f(e.x,e.y),this._initDir=this._tp1Pos.copy(),this._initDir.sub(this._tp2Pos),this.state=exports.GestureRecognizerState.Began)}else if(a!==t.TouchType.TOUCH_MOVED)(a===t.TouchType.TOUCH_ENDED||a===t.TouchType.TOUCH_CANCELED)&&(this.state===exports.GestureRecognizerState.Began||99!==this._tp1Id&&99===this._tp2Id?this.state=exports.GestureRecognizerState.Failed:this.state===exports.GestureRecognizerState.Changed&&(this.state=exports.GestureRecognizerState.Ended));else if(this._tp1Id===e.pointerId?this._tp1Pos=new t.Vector2f(e.x,e.y):this._tp2Id===e.pointerId&&(this._tp2Pos=new t.Vector2f(e.x,e.y)),this.state===exports.GestureRecognizerState.Began||this.state===exports.GestureRecognizerState.Changed){const e=this._tp1Pos.copy();e.sub(this._tp2Pos);const t=this._initDir;let a=e.angle(t);const n=t.x*e.y-t.y*e.x;0<n&&(a=-a),this._deltaYaw=a-this._lastYaw,this._yaw+=this._deltaYaw,this._lastYaw=a,this.state=exports.GestureRecognizerState.Changed}}}class ga extends ca{constructor(e){super(exports.GestureType.Pinch,e),this._tp1Id=99,this._tp1Pos=new t.Vector2f(0,0),this._tp2Id=99,this._tp2Pos=new t.Vector2f(0,0),this._scale=1,this._deltaScale=0,this._initDis=1,this._lastScale=1}get scale(){return this._scale}get delta(){return this._deltaScale}reset(){this._tp1Id=99,this._tp1Pos=new t.Vector2f(0,0),this._tp2Id=99,this._tp2Pos=new t.Vector2f(0,0),this._scale=1,this._initDis=1,this._deltaScale=0,this._lastScale=1}handleTouch(e){const a=e.type;if(this.state!==exports.GestureRecognizerState.Failed)if(a===t.TouchType.TOUCH_BEGAN){if(2<e.count)return void(this.state=exports.GestureRecognizerState.Failed);99===this._tp1Id?(this._tp1Id=e.pointerId,this._tp1Pos=new t.Vector2f(e.x,e.y)):99!==this._tp1Id&&this._tp1Id!==e.pointerId&&99===this._tp2Id&&(this._tp2Id=e.pointerId,this._tp2Pos=new t.Vector2f(e.x,e.y),this._initDis=this._tp1Pos.distance(this._tp2Pos),this.state=exports.GestureRecognizerState.Began)}else a===t.TouchType.TOUCH_MOVED?(this._tp1Id===e.pointerId?this._tp1Pos=new t.Vector2f(e.x,e.y):this._tp2Id===e.pointerId&&(this._tp2Pos=new t.Vector2f(e.x,e.y)),(this.state===exports.GestureRecognizerState.Began||this.state===exports.GestureRecognizerState.Changed)&&(this._lastScale=this._scale,this._scale=this._tp1Pos.distance(this._tp2Pos)/(this._initDis+1e-7),this._deltaScale=this._scale-this._lastScale,this.state=exports.GestureRecognizerState.Changed)):(a===t.TouchType.TOUCH_ENDED||a===t.TouchType.TOUCH_CANCELED)&&(this.state===exports.GestureRecognizerState.Began||99!==this._tp1Id&&99===this._tp2Id?this.state=exports.GestureRecognizerState.Failed:this.state===exports.GestureRecognizerState.Changed&&(this.state=exports.GestureRecognizerState.Ended))}}class _a extends ca{constructor(e){super(exports.GestureType.LongPress,e),this._tp1Pos=new t.Vector2f(0,0),this._tp1Time=0,this._touchPos=new t.Vector2f(0,0),this._minDuration=.501,this._maxDeltaMovement=.02}get position(){return this._touchPos}reset(){this._tp1Pos=new t.Vector2f(0,0),this._tp1Time=0,this._touchPos=new t.Vector2f(0,0)}handleTouch(e){if(this.state!==exports.GestureRecognizerState.Failed){const a=e.type;if(a===t.TouchType.TOUCH_BEGAN)1!==e.count&&(this.state=exports.GestureRecognizerState.Failed),this.state!==exports.GestureRecognizerState.Failed&&(this._tp1Pos=new t.Vector2f(e.x,e.y),this._tp1Time=e.time);else if(a===t.TouchType.TOUCH_MOVED){const a=new t.Vector2f(e.x,e.y),n=this._tp1Pos;a.distance(n)>this._maxDeltaMovement&&(this.state=exports.GestureRecognizerState.Failed)}else if(a===t.TouchType.TOUCH_ENDED||a===t.TouchType.TOUCH_CANCELED){const a=new t.Vector2f(e.x,e.y),n=this._tp1Pos;e.time-this._tp1Time>1e6*this._minDuration&&a.distance(n)<this._maxDeltaMovement?(this._touchPos=a,this.state=exports.GestureRecognizerState.Ended):this.state=exports.GestureRecognizerState.Failed}}}}class fa extends ca{constructor(e){super(exports.GestureType.DoubleTap,e),this._tp1Pos=new t.Vector2f(0,0),this._tp1Time=0,this._tp1leaveTime=0,this._touchPos=new t.Vector2f(0,0),this._maxDuration=.5,this._maxInterval=.2,this._maxDeltaMovement=.02,this._firstReady=!1,this._curTime=0}get position(){return this._touchPos}reset(){this._tp1Pos=new t.Vector2f(0,0),this._tp1Time=0,this._tp1leaveTime=0,this._touchPos=new t.Vector2f(0,0),this._firstReady=!1}update(e){this._curTime+=e,this._firstReady&&this._curTime>this._maxInterval&&(this.state=exports.GestureRecognizerState.Failed,this._firstReady=!1,this._curTime=0)}handleTouch(e){if(this._curTime=0,this.state!==exports.GestureRecognizerState.Failed){const a=e.type;if(a===t.TouchType.TOUCH_BEGAN){if(1!==e.count&&(this.state=exports.GestureRecognizerState.Failed),this.state!==exports.GestureRecognizerState.Failed){if(this._firstReady&&e.time-this._tp1leaveTime>1e6*this._maxInterval)return void(this.state=exports.GestureRecognizerState.Failed);this._tp1Pos=new t.Vector2f(e.x,e.y),this._tp1Time=e.time,this._touchPos=new t.Vector2f(e.x,e.y)}}else if(a===t.TouchType.TOUCH_MOVED){const a=new t.Vector2f(e.x,e.y),n=this._tp1Pos;(e.time-this._tp1Time>1e6*this._maxDuration||a.distance(n)>this._maxDeltaMovement)&&(this.state=exports.GestureRecognizerState.Failed)}else if(a===t.TouchType.TOUCH_ENDED||a===t.TouchType.TOUCH_CANCELED){const a=new t.Vector2f(e.x,e.y),n=this._tp1Pos;if(e.time-this._tp1Time<1e6*this._maxDuration&&a.distance(n)<this._maxDeltaMovement){if(this._firstReady)return void(this.state=exports.GestureRecognizerState.Ended);this._tp1leaveTime=e.time,this._firstReady=!0}else this.state=exports.GestureRecognizerState.Failed}}}}class ha extends e{constructor(){super(),this._currentTouchNum=0,this._mockPoint=[],this._gestureRecognizers=new Map,this._gestureRecognizers.set(exports.GestureType.Tap,new pa(this)),this._gestureRecognizers.set(exports.GestureType.Pan,new ua(this)),this._gestureRecognizers.set(exports.GestureType.Rotation,new ma(this)),this._gestureRecognizers.set(exports.GestureType.Pinch,new ga(this)),this._gestureRecognizers.set(exports.GestureType.LongPress,new _a(this)),this._gestureRecognizers.set(exports.GestureType.DoubleTap,new fa(this))}start(){}destroy(){}get tap(){return this._gestureRecognizers.get(exports.GestureType.Tap)}get pan(){return this._gestureRecognizers.get(exports.GestureType.Pan)}get rotation(){return this._gestureRecognizers.get(exports.GestureType.Rotation)}get pinch(){return this._gestureRecognizers.get(exports.GestureType.Pinch)}get longPress(){return this._gestureRecognizers.get(exports.GestureType.LongPress)}get doubleTap(){return this._gestureRecognizers.get(exports.GestureType.DoubleTap)}pushMockTouch(e){this._mockPoint.push(e)}popMockTouch(){this._mockPoint.pop()}update(e){for(const t of this._gestureRecognizers.keys()){const a=this._gestureRecognizers.get(t);a.update(e)}}_reset(){for(const e of this._gestureRecognizers.keys()){const t=this._gestureRecognizers.get(e);t.state=exports.GestureRecognizerState.Possible,t.reset()}}_countTouch(e){e.type===t.TouchType.TOUCH_BEGAN?this._currentTouchNum++:(e.type===t.TouchType.TOUCH_ENDED||e.type===t.TouchType.TOUCH_CANCELED)&&this._currentTouchNum--}_needReset(){for(const e of this._gestureRecognizers.keys()){const t=this._gestureRecognizers.get(e);if(t.state===exports.GestureRecognizerState.Possible)return!1}return!0}_handleTouch(e){0>=this._currentTouchNum&&this._needReset()&&(this._currentTouchNum=0,this._reset()),this._countTouch(e);for(const t of this._gestureRecognizers.keys()){const a=this._gestureRecognizers.get(t);a.handleTouch(e)}}_handleMockTouch(e){for(let a=0;a<this._mockPoint.length;a++){const n=this._mockPoint[a],i=new t.TouchPointer;i.x=n.x,i.y=n.y,i.type=e.type,i.pointerId=e.pointerId+a+1,i.time=e.time,i.size=e.size,i.force=e.force,i.count=e.count+a+1,this._handleTouch(i)}}onEvent(e){if(e.type===t.EventType.TOUCH){const t=e.args.get(0);this._handleTouch(t),this._handleMockTouch(t)}}}class ya{constructor(e,t,a){this._type=e,this._caster=t,this._entities=a}get type(){return this._type}get caster(){return this._caster}get entities(){return this._entities}}class va extends e{constructor(){super(...arguments),this._raycasterComps=new Map([[exports.ScreenRaycasterType.UI,[]],[exports.ScreenRaycasterType.TwoD,[]],[exports.ScreenRaycasterType.ThreeD,[]],[exports.ScreenRaycasterType.Other,[]],[exports.ScreenRaycasterType.AR,[]]]),this._respondOrder=[exports.ScreenRaycasterType.UI,exports.ScreenRaycasterType.TwoD,exports.ScreenRaycasterType.ThreeD,exports.ScreenRaycasterType.Other,exports.ScreenRaycasterType.AR],this._curTouchNum=0,this._touched=!1,this._fireEndedDirty=!1,this._respondType=exports.TouchRespondType.Once}get type(){return this._respondType}set type(e){this._respondType=e}get order(){return this._respondOrder}set order(e){this._respondOrder=e}start(){const e=Ua.engine.scene.findAllByComponent(Fe);for(let a=0;a<e.length;a++){var t;const n=e[a],i=n.getComponent(Fe);null==(t=this._raycasterComps.get(i.type))?void 0:t.push(i)}}destroy(){}update(){this._fireEndedDirty&&(this.fire(exports.ScreenRespondType.Ended),this._fireEndedDirty=!1)}_fireRespondEvent(e){for(const t of this._respondOrder){if(!this._raycasterComps.has(t))continue;const a=this._raycasterComps.get(t);for(let n=0;n<a.length;n++){const i=a[n];let r;if(r=t===exports.ScreenRaycasterType.UI?i.raycastUI(new T(e.x,1-e.y)):i.raycastOBB(new T(e.x,1-e.y)),0<r.length){const e=new ya(i.type,i,r);this.fire(exports.ScreenRespondType.Respond,e),this._touched=!0}}}}onEvent(e){if(e.type===t.EventType.TOUCH){const a=e.args.get(0);if(a.type===t.TouchType.TOUCH_BEGAN){if(0>=this._curTouchNum&&(this._curTouchNum=0,this.fire(exports.ScreenRespondType.Began)),this._curTouchNum++,this._touched&&this._respondType===exports.TouchRespondType.Once)return;this._fireRespondEvent(new T(a.x,a.y))}else a.type===t.TouchType.TOUCH_MOVED?this._respondType===exports.TouchRespondType.Continuous&&this._fireRespondEvent(new T(a.x,a.y)):(a.type===t.TouchType.TOUCH_ENDED||a.type===t.TouchType.TOUCH_CANCELED)&&(this._curTouchNum--,0>=this._curTouchNum&&(this._curTouchNum=0,this._fireEndedDirty=!0,this._touched=!1))}}}class Ta extends e{constructor(){super(),this._volume=.5,this._lastNode=new t.AMGAudioNode,this._module=t.AmazingManager.getSingleton("AMGAudioModule"),this._audioProxy=this._module.createAudioProxy(new t.Map),this._audioGraph=this._audioProxy.createAudioGraph(),this._volumeNode=this._audioGraph.createAudioNode("GainNode",new t.Map),this._sinkNode=this._audioGraph.createAudioNode("SinkNode",new t.Map),this._effectExtractorList=[]}addEffect(e){const a=e.toEffectNode(this._audioGraph,new t.Map);this._effectExtractorList.push(a),this._lastNode.connect(a),this._lastNode=a}addExtractor(e){const a=e.toExtractorNode(this._audioGraph,new t.Map);this._effectExtractorList.push(a),this._lastNode.connect(a),this._lastNode=a}onUpdate(){}onDestroy(){this._audioProxy.stop(),this._module.destroyAudioProxy(this._audioProxy)}get volume(){return this._volume}set volume(e){this._volume=e,this._volumeNode.gain=this._volume}}class Sa extends Ta{constructor(){super(),this._filePath="",this._numLoops=1,this._loopsDone=0,this._sourceConnected=!1,this._fileStarted=!1,this._startTime=0,this._endTime=-1,this._fileNode=this._audioGraph.createAudioNode("FileSourceNode",new t.Map),this._lastNode=this._fileNode}init(){this._sourceConnected&&!this._fileStarted?(this._fileStarted=!0,0<this._startTime&&this._fileNode.setStartTime(this._startTime),this._endTime!==this._fileNode.getDuration()&&this._fileNode.setEndTime(this._endTime),(-1===this._numLoops||1<this._numLoops)&&this._fileNode.setLoop(!0),this._lastNode.connect(this._volumeNode),this._volumeNode.connect(this._sinkNode),this._volumeNode.pout(0).connect(this._sinkNode.pin(1)),this._audioProxy.useAudioGraph(this._audioGraph),this._audioProxy.start()):console.error("File source not set")}stop(){this._fileNode.stop(),this.fire(exports.AudioEvent.Stop)}onUpdate(){this._fileStarted&&this._loopsDone<this.loopsCompleted&&(this.fire(exports.AudioEvent.LoopCompletion),this._loopsDone=this.loopsCompleted,this.loopsCompleted===this._numLoops&&this.stop())}start(){this._fileNode.start(),this.fire(exports.AudioEvent.Play)}pause(){this._fileNode.pause(),this.fire(exports.AudioEvent.Pause)}resume(){this._fileNode.resume(),this.fire(exports.AudioEvent.Resume)}get filePath(){return this._filePath}set filePath(e){this._filePath=e,this._fileNode.setSource(this._filePath),0===this._fileNode.getDuration()?console.error("File not found"):(this._sourceConnected=!0,this._endTime=this._fileNode.getDuration())}get loopCount(){return this._numLoops}set loopCount(e){this._fileStarted?console.error("Cannot change loop count while file is running"):this._numLoops=e}get loopsCompleted(){return this._fileNode.getLoopCount()}get fileState(){return this._fileNode.getState()}get position(){return this._fileNode.getProgress()}get startTime(){return this._startTime}set startTime(e){this._fileStarted?console.error("Cannot change Start Time while file is running"):this._startTime=e}get endTime(){return this._endTime}set endTime(e){this._fileStarted?console.error("Cannot change End Time while file is running"):this._endTime=e}}class Ca extends Ta{constructor(){super(),this._musicNode=this._audioGraph.createAudioNode("MusicSourceNode",new t.Map),this._lastNode=this._musicNode}init(){this._lastNode.connect(this._volumeNode),this._volumeNode.connect(this._sinkNode),this._volumeNode.pout(0).connect(this._sinkNode.pin(1)),this._audioProxy.useAudioGraph(this._audioGraph),this._audioProxy.start()}start(){this._musicNode.start(),this.fire(exports.AudioEvent.Play)}stop(){this._musicNode.stop(),this.fire(exports.AudioEvent.Stop)}}class Ia extends Ta{constructor(){super(),this._micNode=this._audioGraph.createAudioNode("MicSourceNode",new t.Map),this._lastNode=this._micNode}init(){this._lastNode.connect(this._volumeNode),this._volumeNode.connect(this._sinkNode),this._volumeNode.pout(0).connect(this._sinkNode.pin(1)),this._audioProxy.useAudioGraph(this._audioGraph),this._audioProxy.start()}start(){this._micNode.start(),this.fire(exports.AudioEvent.Play)}stop(){this._micNode.stop(),this.fire(exports.AudioEvent.Stop)}}class xa{constructor(){this._extractorNodeName="",this._nodeCreated=!1,this._resultsSet=!1,this._extractorNode=new t.AMGAudioExtractorNode,this._extractorResults=new t.AudioFeature,this._paramters=new Map}toExtractorNode(e,t){this._extractorNode=e.createAudioExtractorNode(this._extractorNodeName,t);for(const[a,n]of this._paramters)this._extractorNode.setParameter(a,n);return this._nodeCreated=!0,this._extractorNode}setNodeParamter(e,t){this._nodeCreated?console.error("Extractor Paramters can only be set before an AudioController starts"):this._paramters.set(e,t)}updateResults(){if(this._nodeCreated){const e=this._extractorNode.getResult();null!=e&&(this._extractorResults=e.featureList.popBack(),this._resultsSet=!0)}}parseSingleResult(){return this._resultsSet?this._extractorResults.values.get(0):-1}}class Pa extends xa{constructor(){super(),this._numBands=8,this._extractorNodeName="spectrum_display",this._bands=[],this.setNodeParamter("num_output_bin",this._numBands)}get bandNumber(){return this._numBands}set bandNumber(e){1<e&&0==Math.log2(e)%1?(this._numBands=e,this.setNodeParamter("num_output_bin",this._numBands),this._bands=Array(this._numBands)):console.error("The band number must be a power of 2")}get bands(){this.updateResults();const e=this._extractorResults.values;for(let t=0;t<this._numBands;++t)this._bands[t]=e.get(t);return this._bands}get averageBand(){return this.bands.reduce((e,t)=>e+t,0)/this._numBands}}class Ma extends xa{constructor(){super(),this._extractorNodeName="f0_detection"}get pitch(){return this.updateResults(),this.parseSingleResult()}}class Ra extends xa{constructor(){super(),this._extractorNodeName="beat_tracking"}get beats(){return this.updateResults(),this.parseSingleResult()}}class Fa extends xa{constructor(){super(),this._extractorNodeName="volume_detection"}get volumeAmplitude(){return this.updateResults(),this.parseSingleResult()}}class Aa extends xa{constructor(){super(),this._threshold=50,this._extractorNodeName="onset_detection"}get threshold(){return this._threshold}set threshold(e){this._threshold=e,this.setNodeParamter("threshold",e)}get rhythmPointAmplitude(){return this.updateResults(),this.parseSingleResult()}}class Ea{constructor(){this._effectNodeName="",this._nodeCreated=!1,this._map=new t.Map,this._effectNode=new t.AMGAudioEffectNode}toEffectNode(e,t){return this._effectNode=e.createAudioEffectNode(this._effectNodeName,t),this._effectNode.setParameters(this._map),this._nodeCreated=!0,this._effectNode}setNodeParamter(e,t){this._nodeCreated?this._effectNode.setParameter(e,t):this._map.insert(e,t)}}class ka extends Ea{constructor(){super(),this._roomSize=1.5,this._damping=.5,this._stereoBalance=.5,this._wet=.5,this._dry=.5,this._wetGain=.5,this._dryGain=.5,this._effectNodeName="reverb1"}get roomSize(){return this._roomSize}set roomSize(e){this._roomSize=e,this.setNodeParamter("room_size",this._roomSize)}get damping(){return this._damping}set damping(e){this._damping=e,this.setNodeParamter("damping",this._roomSize)}get stereoBalance(){return this._stereoBalance}set stereoBalance(e){this._stereoBalance=e,this.setNodeParamter("stereo_depth",this._roomSize)}get wet(){return this._wet}set wet(e){this._wet=e,this.setNodeParamter("wet",this._roomSize)}get dry(){return this._dry}set dry(e){this._dry=e,this.setNodeParamter("dry",this._roomSize)}get wetGain(){return this._wetGain}set wetGain(e){this._wetGain=e,this.setNodeParamter("wet_gaindB",this._roomSize)}get dryGain(){return this._dryGain}set dryGain(e){this._dryGain=e,this.setNodeParamter("dry_gaindB",this._roomSize)}}class La extends Ea{constructor(){super(),this._lowPass=4e3,this._highPass=500,this._effectNodeName="megaphone"}get lowPass(){return this._lowPass}set lowPass(e){this._lowPass=e,this.setNodeParamter("lpf_fc",this._lowPass)}get highPass(){return this._highPass}set highPass(e){this._highPass=e,this.setNodeParamter("hpf_fc",this._highPass)}}class Na extends Ea{constructor(){super(),this._preGain=0,this._threshold=-24,this._attack=.003,this._release=.25,this._preDelay=.006,this._postGain=0,this._wet=1,this._effectNodeName="compressor"}get preGain(){return this._preGain}set preGain(e){this._preGain=e,this.setNodeParamter("pre_gain",this._preGain)}get threshold(){return this._threshold}set threshold(e){this._threshold=e,this.setNodeParamter("threshold",this._threshold)}get attack(){return this._attack}set attack(e){this._attack=e,this.setNodeParamter("attack",this._attack)}get release(){return this._release}set release(e){this._release=e,this.setNodeParamter("release",this._release)}get preDelay(){return this._preDelay}set preDelay(e){this._preDelay=e,this.setNodeParamter("pre_delay",this._preDelay)}get postGain(){return this._postGain}set postGain(e){this._postGain=e,this.setNodeParamter("post_gain",this._postGain)}get wet(){return this._wet}set wet(e){this._wet=e,this.setNodeParamter("wet",this._wet)}}class ba extends Ea{constructor(){super(),this._delayTime=234,this._feedback=.2,this._wet=.2,this._dry=1,this._effectNodeName="delay"}get delayTime(){return this._delayTime}set delayTime(e){this._delayTime=e,this.setNodeParamter("delay_time",this._delayTime)}get feedback(){return this._feedback}set feedback(e){this._feedback=e,this.setNodeParamter("feedback",this._feedback)}get wet(){return this._wet}set wet(e){this._wet=e,this.setNodeParamter("wet",this._wet)}get dry(){return this._dry}set dry(e){this._dry=e,this.setNodeParamter("dry",this._dry)}}class Da extends Ea{constructor(){super(),this._frequency=100,this._gain=1,this._quality=1,this._filterType=exports.AudioEffectFilterType.LowPass,this._effectNodeName="biquad_filter"}get frequency(){return this._frequency}set frequency(e){this._frequency=e,this.setNodeParamter("freq",this._frequency)}get gain(){return this._gain}set gain(e){this._gain=e,this.setNodeParamter("gain",this._gain)}get quality(){return this._quality}set quality(e){this._quality=e,this.setNodeParamter("quality",this._quality)}get filterType(){return this._filterType}set filterType(e){this._filterType=e,this.setNodeParamter("filter_type",this._filterType)}}class Ba extends Ea{constructor(){super(),this._rate=1,this._amount=1,this._effectNodeName="vibrato"}get rate(){return this._rate}set rate(e){this._rate=e,this.setNodeParamter("rate",this._rate)}get amount(){return this._amount}set amount(e){this._amount=e,this.setNodeParamter("semitones",this._amount)}}class wa extends Ea{constructor(){super(),this._gate=.99,this._preGain=0,this._effectNodeName="climiter"}get gate(){return this._gate}set gate(e){this._gate=e,this.setNodeParamter("gate",this._gate)}get preGain(){return this._preGain}set preGain(e){this._preGain=e,this.setNodeParamter("pregain_dB",this._preGain)}}const Oa="11.2.0";class za{constructor(){this._audioControllers=[]}static getInstance(){return Oe.checkSDKVersion(Oa)?(null==this._instance&&(this._instance=new za),this._instance):(console.warn(`[Amazing JS]: current SDK version[${t.VERSION}] is lower than the minimum required version[${Oa}] for audio module.`),null)}static createAudioController(e){if(!Oe.checkSDKVersion(Oa))return null;switch(e){case exports.AudioControllerType.File:const t=new Sa;return this.getInstance()._audioControllers.push(t),t;case exports.AudioControllerType.Music:const a=new Ca;return this.getInstance()._audioControllers.push(a),a;case exports.AudioControllerType.Mic:const n=new Ia;return this.getInstance()._audioControllers.push(n),n;default:return console.error(`There is no audio ${e} controller`),null;}}static createAudioEffect(e){if(!Oe.checkSDKVersion(Oa))return null;return e===exports.AudioEffectType.Reverb?new ka:e===exports.AudioEffectType.Megaphone?new La:e===exports.AudioEffectType.Compressor?new Na:e===exports.AudioEffectType.Delay?new ba:e===exports.AudioEffectType.Filter?new Da:e===exports.AudioEffectType.Vibrato?new Ba:e===exports.AudioEffectType.Limiter?new wa:(console.error(`There is no ${e} effect`),null)}static createAudioExtractor(e){if(!Oe.checkSDKVersion(Oa))return null;return e===exports.AudioExtractorType.Energy?new Pa:e===exports.AudioExtractorType.PitchDetection?new Ma:e===exports.AudioExtractorType.BeatsDetection?new Ra:e===exports.AudioExtractorType.VolumeDetection?new Fa:e===exports.AudioExtractorType.OnsetDetection?new Aa:(console.error(`There is no ${e} effect`),null)}onUpdate(){for(const e of this._audioControllers)e.onUpdate()}onDestroy(){for(const e of this._audioControllers)e.onDestroy()}}const Va="10.1.0",Ha="11.0.0";class Ua extends e{constructor(e){super(),Oe.checkSDKVersion(Va)||console.error(`[Amazing JS]: current SDK version[${t.VERSION}] is lower than the minimum required version[${Va}]. Amazing JS might not be able run properly.`),this._algorithms=new la,this._scene=new Ee(e),this._assets=new da(this),this._customAssets=new _t;const a=e.getOutputRenderTexture();this._touch=new Ne(a.width,a.height),this._plugins=new oa,Oe.checkSDKVersion(Ha)?(this._touchRespond=new va,this._touchGesture=new ha):(this._touchRespond=null,this._touchGesture=null,console.warn(`[Amazing JS]: current SDK version[${t.VERSION}] is lower than the minimum required version[${Ha}] for touch gesture module.`)),this._audioFactory=za.getInstance(),Ua._engine=this}static get engine(){return Ua._engine}get scene(){return this._scene}get customAssets(){return this._customAssets}get touch(){return this._touch}get assets(){return this._assets}get algoritms(){return this._algorithms}get touchRespond(){return this._touchRespond}get touchGesture(){return this._touchGesture}static init(e){return Ua.engine?void console.warn("Engine already initialized"):void(Ua._engine=new Ua(e),Ua._engine.initModules())}initModules(){Je.getInstance().init(),Xe.getInstance().init(),Kt.getInstance().init(),Jt.getInstance().init(),ea.getInstance().init(),na.getInstance().init(),jt.getInstance().init(),this._customAssets.init()}start(){var e,t;this._touch.start(),null==(e=this._touchRespond)?void 0:e.start(),null==(t=this._touchGesture)?void 0:t.start(),this._customAssets.start(),this._plugins.start();const a=this._plugins.plugins;for(const e in a)this[e]=a[e];this.fire("start")}update(e){var t,a,n;this._algorithms.update(),null==(t=this._audioFactory)?void 0:t.onUpdate(),Je.getInstance().onUpdate(e),Xe.getInstance().onUpdate(),Kt.getInstance().onUpdate(),Jt.getInstance().onUpdate(),ea.getInstance().onUpdate(),na.getInstance().onUpdate(),null==(a=this._touchRespond)?void 0:a.update(e),null==(n=this._touchGesture)?void 0:n.update(e),jt.getInstance().onUpdate(e),this._customAssets.update(e),this._plugins.update(e)}lateUpdate(e){this._customAssets.lateUpdate(e),this._plugins.lateUpdate(e)}destroy(){var e,t,a,n,i;null==(e=this._audioFactory)?void 0:e.onDestroy(),this._plugins.destroy(),this._customAssets.destroy(),this._assets.destroy(),null==(t=this._touch)?void 0:t.destroy(),null==(a=this._scene)?void 0:a.destroy(),null==(n=this.touchRespond)?void 0:n.destroy(),null==(i=this._touchGesture)?void 0:i.destroy(),Ua._engine=void 0}event(e){this._touch&&this._touch.onEvent(e),this._touchRespond&&this._touchRespond.onEvent(e),this._touchGesture&&this._touchGesture.onEvent(e),this._plugins.event(e)}}class Ga extends e{constructor(){super(),this.hasGyroStarted=!1,this.hasGyroStarted=!1}destroy(){}start(){this.hasGyroStarted=!0}get hasStarted(){return this.hasGyroStarted}}var Wa=t.Mesh;Wa.calculateTangents=function(e,t,a,n){const r=[],o=n.length/3,s=e.length,d=new Float32Array(3*s),l=new Float32Array(3*s);for(let r=0;r<o;++r){const t=n[3*r],i=n[3*r+1],o=n[3*r+2],s=e[t],c=e[i],p=e[o],u=a[t],m=a[i],_=a[o],f=c.x-s.x,h=p.x-s.x,y=c.y-s.y,v=p.y-s.y,T=c.z-s.z,S=p.z-s.z,C=m.x-u.x,I=_.x-u.x,x=m.y-u.y,P=_.y-u.y,M=C*P-I*x,R=new g,F=new g;if(0===M)R.set(0,1,0),F.set(1,0,0);else{const e=1/M;R.set((P*f-x*h)*e,(P*y-x*v)*e,(P*T-x*S)*e),F.set((C*h-I*f)*e,(C*v-I*y)*e,(C*S-I*T)*e)}d[3*t+0]+=R.x,d[3*t+1]+=R.y,d[3*t+2]+=R.z,d[3*i+0]+=R.x,d[3*i+1]+=R.y,d[3*i+2]+=R.z,d[3*o+0]+=R.x,d[3*o+1]+=R.y,d[3*o+2]+=R.z,l[3*t+0]+=F.x,l[3*t+1]+=F.y,l[3*t+2]+=F.z,l[3*i+0]+=F.x,l[3*i+1]+=F.y,l[3*i+2]+=F.z,l[3*o+0]+=F.x,l[3*o+1]+=F.y,l[3*o+2]+=F.z}const c=new g,p=new S;for(let o=0;o<s;++o){const e=t[o],a=new g(d[3*o],d[3*o+1],d[3*o+2]),n=new g(l[3*o],l[3*o+1],l[3*o+2]),i=e.dot(a);c.set(e.x,e.y,e.z),c.scale(new g(i,i,i)),c.subtract(a,c).normalize(),p.x=c.x,p.y=c.y,p.z=c.z,c.cross2(e,a),p.w=0>c.dot(n)?-1:1,r.push(p.clone())}return r};function qa(e,t,a,n,i,r,o,s,d,l,c=!1){const p=[],u=[],m=[],_=[],f=1/d,h=1/l,v=d+1,S=new g;for(let g=0;g<l+1;g++){const d=g*(o*h)-.5*o;for(let o=0;o<v;o++){const l=o*(r*f)-.5*r;S[e]=l*n,S[t]=d*i,S[a]=.5*s,p.push(S.clone()),S[e]=0,S[t]=0,S[a]=0<s?1:-1,u.push(S.clone()),m.push(new T(o*f,1-g*h))}}for(let p=0;p<l;p++)for(let e=0;e<d;e++){const t=e+v*p,a=e+v*(p+1),n=e+1+v*(p+1),i=e+1+v*p;_.push(t,a,i),_.push(a,n,i)}const C=c?Wa.calculateTangents(p,u,m,_):void 0;return{positions:p,normals:u,uvs:m,tangents:C,indices:_}}function Ya(e,t,a,n,r,o=!1){var s=Math.cos,d=Math.sin,l=Math.PI;const c=[],p=[],u=[],m=[],_=.5*e;if(0<e)for(let e=0;e<=n;++e)for(let i=0;i<=r;++i){const o=i*(1/r),f=e*(1/n),h=2*o*l,y=d(h),v=s(h),S=new g(y*t,-_,v*t),C=new g(y*a,_,v*a),I=new g().lerp(S,C,f),x=new g().subtract(C,S).normalize(),P=new g(v,0,-y),M=new g().cross2(P,x).normalize();if(c.push(I.clone()),p.push(M.clone()),u.push(new T(o,f)),e<n&&i<r){const t=e*(r+1)+i,a=e*(r+1)+(i+1),n=(e+1)*(r+1)+i,o=(e+1)*(r+1)+(i+1);m.push(t,a,n),m.push(a,o,n)}}const f=o?Wa.calculateTangents(c,p,u,m):void 0;return{positions:c,normals:p,uvs:u,tangents:f,indices:m}}function ja(e,t,a,n=!1,r=0,o="full"){var s=Math.cos,d=Math.sin,l=Math.PI;const c=1/a,p=1/t,u=t/2,m=[],_=[],f=[],h=[],y=0;let v=t,S=1;"top"===o?v=u:"bottom"===o&&(v=u,S=-1);for(let h=y;h<=v;++h){const t=h*l*p,n=d(t),i=s(t);for(let t=0;t<=a;++t){const a=2*t*l*c-.5*l,o=d(a),C=s(a),I=C*n,x=S*i,y=o*n,P=1-t*c,u=1-h*p;m.push(new g(I*e,r+x*e,y*e)),_.push(new g(I,x,y)),f.push(new T(P,u))}}for(let s=y;s<v;++s)for(let e=0;e<a;++e){const t=s*(a+1)+e,n=t+a+1;0<S?(h.push(t+1,n,t),h.push(t+1,n+1,n)):(h.push(t,n,t+1),h.push(n,n+1,t+1))}const C=n?Wa.calculateTangents(m,_,f,h):void 0;return{positions:m,normals:_,uvs:f,tangents:C,indices:h}}function Ka(e,t,a=0,n=!1){var r=Math.cos,o=Math.sin,s=Math.PI;const d=0<=a?1:-1,l=[],c=[],p=[],u=[];if(0<e)for(let n=0;n<t;++n){const i=2*(n*(1/t))*s,m=o(i),_=r(i);l.push(new g(m*e,a,_*e)),c.push(new g(0,d,0)),p.push(new T(1-.5*(m+1),.5*(_+1))),1<n&&(0<d?u.push(n-1,n,0):u.push(0,n,n-1))}const m=n?Wa.calculateTangents(l,c,p,u):void 0;return{positions:l,normals:c,uvs:p,tangents:m,indices:u}}Wa.createMesh=function(e,a,n=!1,r=!1){const o=new t.FloatVector,s=new t.UInt16Vector;let d=0;for(const t of e){const e=t.positions.length;for(let a=0;a<e;++a)o.pushBack(t.positions[a].x),o.pushBack(t.positions[a].y),o.pushBack(t.positions[a].z),o.pushBack(t.normals[a].x),o.pushBack(t.normals[a].y),o.pushBack(t.normals[a].z),o.pushBack(t.uvs[a].x),o.pushBack(t.uvs[a].y),n&&(o.pushBack(t.tangents[a].x),o.pushBack(t.tangents[a].y),o.pushBack(t.tangents[a].z),o.pushBack(t.tangents[a].w)),r&&(o.pushBack(t.colors[a].r),o.pushBack(t.colors[a].g),o.pushBack(t.colors[a].b),o.pushBack(t.colors[a].a));for(const e of t.indices)s.pushBack(d+e);d+=e}const l=new Wa;l.boundingBox=a,l.vertices=o;const c=new t.Vector,p=new t.VertexAttribDesc;p.semantic=t.VertexAttribType.POSITION,c.pushBack(p);const u=new t.VertexAttribDesc;u.semantic=t.VertexAttribType.NORMAL,c.pushBack(u);const m=new t.VertexAttribDesc;if(m.semantic=t.VertexAttribType.TEXCOORD0,c.pushBack(m),n){const e=new t.VertexAttribDesc;e.semantic=t.VertexAttribType.TANGENT,c.pushBack(e)}if(r){const e=new t.VertexAttribDesc;e.semantic=t.VertexAttribType.COLOR,c.pushBack(e)}l.vertexAttribs=c;const g=new t.SubMesh;return g.indices16=s,g.primitive=t.Primitive.TRIANGLES,g.boundingBox=a,l.addSubMesh(g),l},Wa.box=function(e){const a=e&&e.halfExtents!==void 0?e.halfExtents:new g(.5,.5,.5),n=!!(e&&e.withTangents!==void 0)&&e.withTangents,i=2*a.x,r=2*a.y,o=2*a.z,s=1,d=1,l=1,c=.5*i,p=.5*r,u=.5*o,m=qa("z","y","x",-1,-1,o,r,i,l,d,n),_=qa("z","y","x",1,-1,o,r,-i,l,d,n),f=qa("x","z","y",1,1,i,o,r,s,l,n),h=qa("x","z","y",1,-1,i,o,-r,s,l,n),y=qa("x","y","z",1,-1,i,r,o,s,d,n),v=qa("x","y","z",-1,-1,i,r,-o,s,d,n),T=new t.AABB;T.min_x=-c,T.min_y=-p,T.min_z=-u,T.max_x=c,T.max_y=p,T.max_z=u;const S=Wa.createMesh([m,_,f,h,y,v],T,n);return S},Wa.cylinder=function(e){const a=e&&e.radius!==void 0?e.radius:.5,n=e&&e.height!==void 0?e.height:1,i=e&&e.heightSegments!==void 0?e.heightSegments:5,r=e&&e.capSegments!==void 0?e.capSegments:20,o=!!(e&&e.withTangents!==void 0)&&e.withTangents,s=new t.AABB;s.min_x=-a,s.min_y=.5*-n,s.min_z=-a,s.max_x=a,s.max_y=.5*n,s.max_z=a;const d=Ka(a,r,.5*-n,o),l=Ya(n,a,a,i,r,o),c=Ka(a,r,.5*n,o),p=Wa.createMesh([d,l,c],s,o);return p},Wa.cone=function(e){const a=!!(e&&e.withTangents!==void 0)&&e.withTangents,n=e&&e.bottomRadius!==void 0?e.bottomRadius:.5,i=e&&e.topRadius!==void 0?e.topRadius:0,r=e&&e.height!==void 0?e.height:1,o=e&&e.heightSegments!==void 0?e.heightSegments:5,s=e&&e.capSegments!==void 0?e.capSegments:20,d=Math.max(n,i),l=new t.AABB;l.min_x=-d,l.min_y=.5*-r,l.min_z=-d,l.max_x=d,l.max_y=.5*-r,l.max_z=d;const c=Ka(n,s,.5*-r,a),p=Ya(r,n,i,o,s,a),u=0<i?Ka(i,s,.5*r,a):void 0,m=0<i?[c,p,u]:[c,p],g=Wa.createMesh(m,l,a);return g},Wa.plane=function(e){const a=!!(e&&e.withTangents!==void 0)&&e.withTangents,n=e&&e.width!==void 0?e.width:1,i=e&&e.length!==void 0?e.length:1,r=e&&e.widthSegments!==void 0?e.widthSegments:5,o=e&&e.lengthSegments!==void 0?e.lengthSegments:5,s=.5*n,d=.5*i,l=new t.AABB;l.min_x=-s,l.min_y=0,l.min_z=-d,l.max_x=s,l.max_y=0,l.max_z=d;const c=qa("x","z","y",1,1,n,i,0,r,o,a),p=Wa.createMesh([c],l,a);return p},Wa.sphere=function(e){const a=!!(e&&e.withTangents!==void 0)&&e.withTangents,n=e&&e.radius!==void 0?e.radius:.5,i=e&&e.widthSegments!==void 0?e.widthSegments:16,r=e&&e.heightSegments!==void 0?e.heightSegments:16,o=new t.AABB;o.min_x=-n,o.min_y=-n,o.min_z=-n,o.max_x=n,o.max_y=n,o.max_z=n;const s=ja(n,i,r,a),d=Wa.createMesh([s],o,a);return d},Wa.capsule=function(e){const a=!!(e&&e.withTangents!==void 0)&&e.withTangents,n=e&&e.radius!==void 0?e.radius:.5,i=e&&e.height!==void 0?e.height:1,r=e&&e.heightSegments!==void 0?e.heightSegments:5,o=e&&e.capSegments!==void 0?e.capSegments:20,s=new t.AABB;s.min_x=-n,s.min_y=.5*-i-n,s.min_z=-n,s.max_x=n,s.max_y=.5*i+n,s.max_z=n;const d=Ya(i,n,n,r,o,a),l=ja(n,o,o,a,.5*i,"top"),c=ja(n,o,o,a,.5*-i,"bottom"),p=Wa.createMesh([c,d,l],s,a);return p},Wa.torus=function(e){var a=Math.cos,n=Math.sin,r=Math.PI;const o=!!(e&&e.withTangents!==void 0)&&e.withTangents,s=e&&e.tubeRadius!==void 0?e.tubeRadius:.2,d=e&&e.ringRadius!==void 0?e.ringRadius:.3,l=e&&e.ringSegments!==void 0?e.ringSegments:20,c=e&&e.tubeSegments!==void 0?e.tubeSegments:20,p=s+d,u=new t.AABB;u.min_x=-p,u.min_y=-s,u.min_z=-p,u.max_x=p,u.max_y=s,u.max_z=p;const m=[],_=[],f=[],h=[];for(let t=0;t<=l;++t){const e=t*(1/l);for(let i=0;i<=c;++i){const o=i*(1/c),p=a(2*r*e),u=a(2*r*o),y=n(2*r*e),v=n(2*r*o);if(m.push(new g(u*(d+s*p),y*s,v*(d+s*p))),_.push(new g(u*p,y,v*p)),f.push(new T(e,1-o)),t<l&&i<c){const e=t*(c+1)+i,a=(t+1)*(c+1)+i,n=t*(c+1)+(i+1),r=(t+1)*(c+1)+(i+1);h.push(e,a,n),h.push(a,r,n)}}}const y=o?Wa.calculateTangents(m,_,f,h):void 0,v=Wa.createMesh([{positions:m,normals:_,uvs:f,tangents:y,indices:h}],u,o);return v};class Xa{constructor(e){if(!e.attributes)throw new Error("No shader attributes found!");if(!e.vshader)throw new Error("No vertex shader found!");if(!e.fshader)throw new Error("No fragment shader found!");const a=new t.Map;for(const t in e.attributes)a.insert(t,e.attributes[t]);const n=new t.Shader;n.type=t.ShaderType.VERTEX,n.source=e.vshader;const i=new t.Shader;i.type=t.ShaderType.FRAGMENT,i.source=e.fshader;const r=new t.Vector;r.pushBack(n),r.pushBack(i);const o=new t.Map;o.insert("gles2",r);const s=new t.RenderState;s.depthstencil=new t.DepthStencilState,s.depthstencil.depthTestEnable=!0,s.depthstencil.depthWriteEnable=!0,s.depthstencil.stencilTestEnable=!1,s.depthstencil.depthCompareOp=t.CompareOp.LESS;const d=new t.RasterizationState;s.rasterization=d,d.cullMode=t.CullFace.BACK;const l=new t.ColorBlendAttachmentState;l.srcColorBlendFactor=t.BlendFactor.SRC_ALPHA,l.dstColorBlendFactor=t.BlendFactor.ONE_MINUS_SRC_ALPHA,l.srcAlphaBlendFactor=t.BlendFactor.ONE,l.dstAlphaBlendFactor=t.BlendFactor.ONE,l.colorWriteMask=15,l.ColorBlendOp=t.BlendOp.ADD,l.AlphaBlendOp=t.BlendOp.ADD,l.blendEnable=!0;const c=new t.Vector;c.pushBack(l);const p=new t.ColorBlendState;p.attachments=c,s.colorBlend=p;const u=new t.Pass;u.semantics=a,u.shaders=o,u.renderState=s;const m=new t.Vector;m.pushBack(u),this.native=new t.XShader,this.native.passes=m}}class Qa{onInit(){this.sce=Ua.engine.scene,this.entity=this.sce.entityFromNative(this.entity),this.engine=Ua.engine;for(const e of this.entity.getComponents(Me))if(e.script===this){this.component=e;break}}}var Ja=t.Matrix3x3f,Za=t.Rect,$a=t.AABB;function en(e,t,a,n){const r=[],o=n.length/3,s=e.length,d=new Float32Array(3*s),l=new Float32Array(3*s);for(let r=0;r<o;++r){const t=n[3*r],i=n[3*r+1],o=n[3*r+2],s=e[t],c=e[i],p=e[o],u=a[t],m=a[i],_=a[o],f=c.x-s.x,h=p.x-s.x,y=c.y-s.y,v=p.y-s.y,T=c.z-s.z,S=p.z-s.z,C=m.x-u.x,I=_.x-u.x,x=m.y-u.y,P=_.y-u.y,M=C*P-I*x,R=new g,F=new g;if(0===M)R.set(0,1,0),F.set(1,0,0);else{const e=1/M;R.set((P*f-x*h)*e,(P*y-x*v)*e,(P*T-x*S)*e),F.set((C*h-I*f)*e,(C*v-I*y)*e,(C*S-I*T)*e)}d[3*t+0]+=R.x,d[3*t+1]+=R.y,d[3*t+2]+=R.z,d[3*i+0]+=R.x,d[3*i+1]+=R.y,d[3*i+2]+=R.z,d[3*o+0]+=R.x,d[3*o+1]+=R.y,d[3*o+2]+=R.z,l[3*t+0]+=F.x,l[3*t+1]+=F.y,l[3*t+2]+=F.z,l[3*i+0]+=F.x,l[3*i+1]+=F.y,l[3*i+2]+=F.z,l[3*o+0]+=F.x,l[3*o+1]+=F.y,l[3*o+2]+=F.z}const c=new g,p=new S;for(let o=0;o<s;++o){const e=t[o],a=new g(d[3*o],d[3*o+1],d[3*o+2]),n=new g(l[3*o],l[3*o+1],l[3*o+2]),i=e.dot(a);c.set(e.x,e.y,e.z),c.scale(new g(i,i,i)),c.subtract(a,c).normalize(),p.x=c.x,p.y=c.y,p.z=c.z,c.cross2(e,a),p.w=0>c.dot(n)?-1:1,r.push(p.clone())}return r}function tn(e,t,a,n,i,r,o,s,d,l){const c=[],p=[],u=[],m=[],_=1/d,f=1/l,h=d+1,v=new g;for(let m=0;m<l+1;m++){const d=m*(o*f)-.5*o;for(let o=0;o<h;o++){const l=o*(r*_)-.5*r;v[e]=l*n,v[t]=d*i,v[a]=.5*s,c.push(v.clone()),v[e]=0,v[t]=0,v[a]=0<s?1:-1,p.push(v.clone()),u.push(new T(o*_,1-m*f))}}for(let p=0;p<l;p++)for(let e=0;e<d;e++){const t=e+h*p,a=e+h*(p+1),n=e+1+h*(p+1),i=e+1+h*p;m.push(t,a,i),m.push(a,n,i)}const S=en(c,p,u,m);return{positions:c,normals:p,uvs:u,tangents:S,indices:m}}function an(e){var a=Math.floor;const n=e&&void 0!==e.width?e.width:1,i=e&&void 0!==e.height?e.height:1,r=e&&void 0!==e.depth?e.depth:1;let o=e&&void 0!==e.widthSegments?e.widthSegments:1,s=e&&void 0!==e.heightSegments?e.heightSegments:1,d=e&&void 0!==e.depthSegments?e.depthSegments:1;const l=.5*n,c=.5*i,p=.5*r;o=a(o)||1,s=a(s)||1,d=a(d)||1;const u=tn("z","y","x",-1,-1,r,i,n,d,s),m=tn("z","y","x",1,-1,r,i,-n,d,s),g=tn("x","z","y",1,1,n,r,i,o,d),_=tn("x","z","y",1,-1,n,r,-i,o,d),f=tn("x","y","z",1,-1,n,i,r,o,s),h=tn("x","y","z",-1,-1,n,i,-r,o,s),y=new t.AABB;return y.min_x=-l,y.min_y=-c,y.min_z=-p,y.max_x=l,y.max_y=c,y.max_z=p,{data:[u,m,g,_,f,h],aabb:y}}var nn={__proto__:null,box:an};class rn{constructor(e,t){this._name=e,this._context=t}equals(e){return this._name===e.name}get name(){return this._name}get context(){return this._context}onEnter(){}onExit(){}onUpdate(){}onEvent(){}toString(){return`[${this._name}]`}}class on{constructor(){this._registeredStates=new Map}setState(){}removeState(){}onUpdate(){}onEvent(){}registerState(e){this._registeredStates.has(e.name)&&console.log(`State [${e.name}] already registered! Overriding`),this._registeredStates.set(e.name,e)}}class sn extends on{constructor(){super(...arguments),this._currentStates=new Set}onUpdate(e){for(const t of this._currentStates){const a=this._registeredStates.get(t);a&&a.onUpdate(e)}}onEvent(e){for(const t of this._currentStates){const a=this._registeredStates.get(t);a&&a.onEvent(e)}}setState(e){if(!this._registeredStates.has(e))return void console.log(`Unrecognized state [${e}]`);const t=this._registeredStates.get(e);this._currentStates.has(e)||(t&&t.onEnter(),this._currentStates.add(e))}removeState(e){if(this._registeredStates.has(e)||console.log(`Unrecognized state [${e}]`),this._currentStates.has(e)){const t=this._registeredStates.get(e);t&&t.onExit(),this._currentStates.delete(e)}}}class dn extends on{constructor(){super(...arguments),this._currentState=null,this._transitions=new Map}addTransition(e,t){if(this._registeredStates.has(e)&&this._registeredStates.has(t)){this._transitions.has(e)||this._transitions.set(e,new Set);const a=this._transitions.get(e);a&&a.add(t)}}isValidTransition(e,t){const a=this._transitions.get(e);return!!a&&a.has(t)}setState(e){if(this._registeredStates.has(e)){if(this._currentState&&this.isValidTransition(this._currentState.name,e)){const e=this._currentState;e.onExit()}const t=this._registeredStates.get(e);t&&t.onEnter(),this._currentState=t}}removeState(e){this._currentState&&this._currentState.name===e&&(this._currentState.onExit(),this._currentState=null)}onUpdate(e){this._currentState&&this._currentState.onUpdate(e)}onEvent(e){this._currentState&&this._currentState.onEvent(e)}}exports.AABB=$a,exports.AlignmentComponent=he,exports.AnimationComponent=Se,exports.AudioComponent=Ie,exports.AudioFactory=za,exports.AvatarDrive=na,exports.Body2D=Jt,exports.Body3D=ea,exports.ButtonComponent=Z,exports.CameraComponent=d,exports.CanvasComponent=V,exports.CanvasScalerComponent=me,exports.Collider3DComponent=u,exports.Color=m,exports.ConvFilter=It,exports.CustomComponent=Me,exports.DoubleTapGestureRecognizer=fa,exports.Engine=Ua,exports.Entity=Ae,exports.EntityLayerMax=64,exports.EntityTagMax=o,exports.EventHandler=e,exports.FilterGraph=Yt,exports.FilterGraphRegistry=jt,exports.FilterNode=ft,exports.FiniteStateMachine=dn,exports.GenericJoint3DComponent=ve,exports.Geometry=nn,exports.Gyroscope=Ga,exports.Hand=Kt,exports.Head=Xe,exports.ImageComponent=O,exports.ImagePixelFormat=i,exports.LabelComponent=pe,exports.LayoutComponent=_e,exports.LightComponent=y,exports.LongPressGestureRecognizer=_a,exports.Mat3=Ja,exports.Mat4=C,exports.Material=I,exports.Mesh=Wa,exports.ModelComponent=P,exports.MultiToggleStateMachine=sn,exports.OperatorFilter=St,exports.PanGestureRecognizer=ua,exports.ParticleSystemComponent=A,exports.PinchGestureRecognizer=ga,exports.PingpongFilter=Ct,exports.Quat=R,exports.Rect=Za,exports.RigidBody3DComponent=b,exports.RotationGestureRecognizer=ma,exports.Scene=Ee,exports.ScreenHitInfo=ya,exports.ScreenRaycasterComponent=Fe,exports.ScreenTransformComponent=Pe,exports.Script=Qa,exports.Segmentation=Je,exports.SeqAnimationComponent=W,exports.SliderComponent=se,exports.SliderThumbComponent=le,exports.SpriteComponent=U,exports.State=rn,exports.TapGestureRecognizer=pa,exports.TouchDevice=Ne,exports.TouchGesture=ha,exports.TouchRespond=va,exports.Trigger3DComponent=q,exports.UIColliderComponent=ie,exports.UIEventSystemComponent=ee,exports.Vec2=T,exports.Vec3=g,exports.Vec4=S,exports.XShader=Xa;